schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
expression to compare columns of type Int. All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""
columns and relationships of "activity"
"""
type activity {
  createdAt: timestamp!
  date: date!
  deletedAt: timestamp
  description: String
  duration: Int!

  """
  An object relationship
  """
  employee: employee!
  employeeId: uuid!
  id: uuid!
  metaData(
    """
    JSON select path
    """
    path: String
  ): json
  organizationId: uuid
  projectId: uuid
  source: String!

  """
  An object relationship
  """
  task: task
  taskId: uuid
  tenantId: uuid
  time: time!
  timeSlotId: uuid

  """
  An object relationship
  """
  time_slot: time_slot
  title: String!
  type: String
  updatedAt: timestamp!
}

"""
aggregated selection of "activity"
"""
type activity_aggregate {
  aggregate: activity_aggregate_fields
  nodes: [activity!]!
}

"""
aggregate fields of "activity"
"""
type activity_aggregate_fields {
  avg: activity_avg_fields
  count(columns: [activity_select_column!], distinct: Boolean): Int
  max: activity_max_fields
  min: activity_min_fields
  stddev: activity_stddev_fields
  stddev_pop: activity_stddev_pop_fields
  stddev_samp: activity_stddev_samp_fields
  sum: activity_sum_fields
  var_pop: activity_var_pop_fields
  var_samp: activity_var_samp_fields
  variance: activity_variance_fields
}

"""
order by aggregate values of table "activity"
"""
input activity_aggregate_order_by {
  avg: activity_avg_order_by
  count: order_by
  max: activity_max_order_by
  min: activity_min_order_by
  stddev: activity_stddev_order_by
  stddev_pop: activity_stddev_pop_order_by
  stddev_samp: activity_stddev_samp_order_by
  sum: activity_sum_order_by
  var_pop: activity_var_pop_order_by
  var_samp: activity_var_samp_order_by
  variance: activity_variance_order_by
}

"""
input type for inserting array relation for remote table "activity"
"""
input activity_arr_rel_insert_input {
  data: [activity_insert_input!]!
  on_conflict: activity_on_conflict
}

"""
aggregate avg on columns
"""
type activity_avg_fields {
  duration: Float
}

"""
order by avg() on columns of table "activity"
"""
input activity_avg_order_by {
  duration: order_by
}

"""
Boolean expression to filter rows from the table "activity". All fields are combined with a logical 'AND'.
"""
input activity_bool_exp {
  _and: [activity_bool_exp]
  _not: activity_bool_exp
  _or: [activity_bool_exp]
  createdAt: timestamp_comparison_exp
  date: date_comparison_exp
  deletedAt: timestamp_comparison_exp
  description: String_comparison_exp
  duration: Int_comparison_exp
  employee: employee_bool_exp
  employeeId: uuid_comparison_exp
  id: uuid_comparison_exp
  metaData: json_comparison_exp
  organizationId: uuid_comparison_exp
  projectId: uuid_comparison_exp
  source: String_comparison_exp
  task: task_bool_exp
  taskId: uuid_comparison_exp
  tenantId: uuid_comparison_exp
  time: time_comparison_exp
  timeSlotId: uuid_comparison_exp
  time_slot: time_slot_bool_exp
  title: String_comparison_exp
  type: String_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "activity"
"""
enum activity_constraint {
  """
  unique or primary key constraint
  """
  PK_24625a1d6b1b089c8ae206fe467
}

"""
input type for incrementing integer column in table "activity"
"""
input activity_inc_input {
  duration: Int
}

"""
input type for inserting data into table "activity"
"""
input activity_insert_input {
  createdAt: timestamp
  date: date
  deletedAt: timestamp
  description: String
  duration: Int
  employee: employee_obj_rel_insert_input
  employeeId: uuid
  id: uuid
  metaData: json
  organizationId: uuid
  projectId: uuid
  source: String
  task: task_obj_rel_insert_input
  taskId: uuid
  tenantId: uuid
  time: time
  timeSlotId: uuid
  time_slot: time_slot_obj_rel_insert_input
  title: String
  type: String
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type activity_max_fields {
  createdAt: timestamp
  date: date
  deletedAt: timestamp
  description: String
  duration: Int
  employeeId: uuid
  id: uuid
  organizationId: uuid
  projectId: uuid
  source: String
  taskId: uuid
  tenantId: uuid
  timeSlotId: uuid
  title: String
  type: String
  updatedAt: timestamp
}

"""
order by max() on columns of table "activity"
"""
input activity_max_order_by {
  createdAt: order_by
  date: order_by
  deletedAt: order_by
  description: order_by
  duration: order_by
  employeeId: order_by
  id: order_by
  organizationId: order_by
  projectId: order_by
  source: order_by
  taskId: order_by
  tenantId: order_by
  timeSlotId: order_by
  title: order_by
  type: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type activity_min_fields {
  createdAt: timestamp
  date: date
  deletedAt: timestamp
  description: String
  duration: Int
  employeeId: uuid
  id: uuid
  organizationId: uuid
  projectId: uuid
  source: String
  taskId: uuid
  tenantId: uuid
  timeSlotId: uuid
  title: String
  type: String
  updatedAt: timestamp
}

"""
order by min() on columns of table "activity"
"""
input activity_min_order_by {
  createdAt: order_by
  date: order_by
  deletedAt: order_by
  description: order_by
  duration: order_by
  employeeId: order_by
  id: order_by
  organizationId: order_by
  projectId: order_by
  source: order_by
  taskId: order_by
  tenantId: order_by
  timeSlotId: order_by
  title: order_by
  type: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "activity"
"""
type activity_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [activity!]!
}

"""
input type for inserting object relation for remote table "activity"
"""
input activity_obj_rel_insert_input {
  data: activity_insert_input!
  on_conflict: activity_on_conflict
}

"""
on conflict condition type for table "activity"
"""
input activity_on_conflict {
  constraint: activity_constraint!
  update_columns: [activity_update_column!]!
  where: activity_bool_exp
}

"""
ordering options when selecting data from "activity"
"""
input activity_order_by {
  createdAt: order_by
  date: order_by
  deletedAt: order_by
  description: order_by
  duration: order_by
  employee: employee_order_by
  employeeId: order_by
  id: order_by
  metaData: order_by
  organizationId: order_by
  projectId: order_by
  source: order_by
  task: task_order_by
  taskId: order_by
  tenantId: order_by
  time: order_by
  timeSlotId: order_by
  time_slot: time_slot_order_by
  title: order_by
  type: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "activity"
"""
input activity_pk_columns_input {
  id: uuid!
}

"""
select columns of table "activity"
"""
enum activity_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  date

  """
  column name
  """
  deletedAt

  """
  column name
  """
  description

  """
  column name
  """
  duration

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  metaData

  """
  column name
  """
  organizationId

  """
  column name
  """
  projectId

  """
  column name
  """
  source

  """
  column name
  """
  taskId

  """
  column name
  """
  tenantId

  """
  column name
  """
  time

  """
  column name
  """
  timeSlotId

  """
  column name
  """
  title

  """
  column name
  """
  type

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "activity"
"""
input activity_set_input {
  createdAt: timestamp
  date: date
  deletedAt: timestamp
  description: String
  duration: Int
  employeeId: uuid
  id: uuid
  metaData: json
  organizationId: uuid
  projectId: uuid
  source: String
  taskId: uuid
  tenantId: uuid
  time: time
  timeSlotId: uuid
  title: String
  type: String
  updatedAt: timestamp
}

"""
aggregate stddev on columns
"""
type activity_stddev_fields {
  duration: Float
}

"""
order by stddev() on columns of table "activity"
"""
input activity_stddev_order_by {
  duration: order_by
}

"""
aggregate stddev_pop on columns
"""
type activity_stddev_pop_fields {
  duration: Float
}

"""
order by stddev_pop() on columns of table "activity"
"""
input activity_stddev_pop_order_by {
  duration: order_by
}

"""
aggregate stddev_samp on columns
"""
type activity_stddev_samp_fields {
  duration: Float
}

"""
order by stddev_samp() on columns of table "activity"
"""
input activity_stddev_samp_order_by {
  duration: order_by
}

"""
aggregate sum on columns
"""
type activity_sum_fields {
  duration: Int
}

"""
order by sum() on columns of table "activity"
"""
input activity_sum_order_by {
  duration: order_by
}

"""
update columns of table "activity"
"""
enum activity_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  date

  """
  column name
  """
  deletedAt

  """
  column name
  """
  description

  """
  column name
  """
  duration

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  metaData

  """
  column name
  """
  organizationId

  """
  column name
  """
  projectId

  """
  column name
  """
  source

  """
  column name
  """
  taskId

  """
  column name
  """
  tenantId

  """
  column name
  """
  time

  """
  column name
  """
  timeSlotId

  """
  column name
  """
  title

  """
  column name
  """
  type

  """
  column name
  """
  updatedAt
}

"""
aggregate var_pop on columns
"""
type activity_var_pop_fields {
  duration: Float
}

"""
order by var_pop() on columns of table "activity"
"""
input activity_var_pop_order_by {
  duration: order_by
}

"""
aggregate var_samp on columns
"""
type activity_var_samp_fields {
  duration: Float
}

"""
order by var_samp() on columns of table "activity"
"""
input activity_var_samp_order_by {
  duration: order_by
}

"""
aggregate variance on columns
"""
type activity_variance_fields {
  duration: Float
}

"""
order by variance() on columns of table "activity"
"""
input activity_variance_order_by {
  duration: order_by
}

"""
columns and relationships of "appointment_employee"
"""
type appointment_employee {
  appointmentId: String!
  createdAt: timestamp!
  employeeAppointmentId: uuid
  employeeId: String!

  """
  An object relationship
  """
  employee_appointment: employee_appointment
  id: uuid!
  organizationId: uuid
  tenantId: uuid
  updatedAt: timestamp!
}

"""
aggregated selection of "appointment_employee"
"""
type appointment_employee_aggregate {
  aggregate: appointment_employee_aggregate_fields
  nodes: [appointment_employee!]!
}

"""
aggregate fields of "appointment_employee"
"""
type appointment_employee_aggregate_fields {
  count(columns: [appointment_employee_select_column!], distinct: Boolean): Int
  max: appointment_employee_max_fields
  min: appointment_employee_min_fields
}

"""
order by aggregate values of table "appointment_employee"
"""
input appointment_employee_aggregate_order_by {
  count: order_by
  max: appointment_employee_max_order_by
  min: appointment_employee_min_order_by
}

"""
input type for inserting array relation for remote table "appointment_employee"
"""
input appointment_employee_arr_rel_insert_input {
  data: [appointment_employee_insert_input!]!
  on_conflict: appointment_employee_on_conflict
}

"""
Boolean expression to filter rows from the table "appointment_employee". All fields are combined with a logical 'AND'.
"""
input appointment_employee_bool_exp {
  _and: [appointment_employee_bool_exp]
  _not: appointment_employee_bool_exp
  _or: [appointment_employee_bool_exp]
  appointmentId: String_comparison_exp
  createdAt: timestamp_comparison_exp
  employeeAppointmentId: uuid_comparison_exp
  employeeId: String_comparison_exp
  employee_appointment: employee_appointment_bool_exp
  id: uuid_comparison_exp
  organizationId: uuid_comparison_exp
  tenantId: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "appointment_employee"
"""
enum appointment_employee_constraint {
  """
  unique or primary key constraint
  """
  PK_cad339a11ed0408e417671162fb
}

"""
input type for inserting data into table "appointment_employee"
"""
input appointment_employee_insert_input {
  appointmentId: String
  createdAt: timestamp
  employeeAppointmentId: uuid
  employeeId: String
  employee_appointment: employee_appointment_obj_rel_insert_input
  id: uuid
  organizationId: uuid
  tenantId: uuid
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type appointment_employee_max_fields {
  appointmentId: String
  createdAt: timestamp
  employeeAppointmentId: uuid
  employeeId: String
  id: uuid
  organizationId: uuid
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by max() on columns of table "appointment_employee"
"""
input appointment_employee_max_order_by {
  appointmentId: order_by
  createdAt: order_by
  employeeAppointmentId: order_by
  employeeId: order_by
  id: order_by
  organizationId: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type appointment_employee_min_fields {
  appointmentId: String
  createdAt: timestamp
  employeeAppointmentId: uuid
  employeeId: String
  id: uuid
  organizationId: uuid
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by min() on columns of table "appointment_employee"
"""
input appointment_employee_min_order_by {
  appointmentId: order_by
  createdAt: order_by
  employeeAppointmentId: order_by
  employeeId: order_by
  id: order_by
  organizationId: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "appointment_employee"
"""
type appointment_employee_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [appointment_employee!]!
}

"""
input type for inserting object relation for remote table "appointment_employee"
"""
input appointment_employee_obj_rel_insert_input {
  data: appointment_employee_insert_input!
  on_conflict: appointment_employee_on_conflict
}

"""
on conflict condition type for table "appointment_employee"
"""
input appointment_employee_on_conflict {
  constraint: appointment_employee_constraint!
  update_columns: [appointment_employee_update_column!]!
  where: appointment_employee_bool_exp
}

"""
ordering options when selecting data from "appointment_employee"
"""
input appointment_employee_order_by {
  appointmentId: order_by
  createdAt: order_by
  employeeAppointmentId: order_by
  employeeId: order_by
  employee_appointment: employee_appointment_order_by
  id: order_by
  organizationId: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "appointment_employee"
"""
input appointment_employee_pk_columns_input {
  id: uuid!
}

"""
select columns of table "appointment_employee"
"""
enum appointment_employee_select_column {
  """
  column name
  """
  appointmentId

  """
  column name
  """
  createdAt

  """
  column name
  """
  employeeAppointmentId

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  organizationId

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "appointment_employee"
"""
input appointment_employee_set_input {
  appointmentId: String
  createdAt: timestamp
  employeeAppointmentId: uuid
  employeeId: String
  id: uuid
  organizationId: uuid
  tenantId: uuid
  updatedAt: timestamp
}

"""
update columns of table "appointment_employee"
"""
enum appointment_employee_update_column {
  """
  column name
  """
  appointmentId

  """
  column name
  """
  createdAt

  """
  column name
  """
  employeeAppointmentId

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  organizationId

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
columns and relationships of "availability_slot"
"""
type availability_slot {
  allDay: Boolean!
  createdAt: timestamp!

  """
  An object relationship
  """
  employee: employee
  employeeId: uuid
  endTime: timestamp!
  id: uuid!
  organizationId: uuid
  startTime: timestamp!
  tenantId: uuid
  type: String!
  updatedAt: timestamp!
}

"""
aggregated selection of "availability_slot"
"""
type availability_slot_aggregate {
  aggregate: availability_slot_aggregate_fields
  nodes: [availability_slot!]!
}

"""
aggregate fields of "availability_slot"
"""
type availability_slot_aggregate_fields {
  count(columns: [availability_slot_select_column!], distinct: Boolean): Int
  max: availability_slot_max_fields
  min: availability_slot_min_fields
}

"""
order by aggregate values of table "availability_slot"
"""
input availability_slot_aggregate_order_by {
  count: order_by
  max: availability_slot_max_order_by
  min: availability_slot_min_order_by
}

"""
input type for inserting array relation for remote table "availability_slot"
"""
input availability_slot_arr_rel_insert_input {
  data: [availability_slot_insert_input!]!
  on_conflict: availability_slot_on_conflict
}

"""
Boolean expression to filter rows from the table "availability_slot". All fields are combined with a logical 'AND'.
"""
input availability_slot_bool_exp {
  _and: [availability_slot_bool_exp]
  _not: availability_slot_bool_exp
  _or: [availability_slot_bool_exp]
  allDay: Boolean_comparison_exp
  createdAt: timestamp_comparison_exp
  employee: employee_bool_exp
  employeeId: uuid_comparison_exp
  endTime: timestamp_comparison_exp
  id: uuid_comparison_exp
  organizationId: uuid_comparison_exp
  startTime: timestamp_comparison_exp
  tenantId: uuid_comparison_exp
  type: String_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "availability_slot"
"""
enum availability_slot_constraint {
  """
  unique or primary key constraint
  """
  PK_62a782c29fd83da5ba7c4ea55f7
}

"""
input type for inserting data into table "availability_slot"
"""
input availability_slot_insert_input {
  allDay: Boolean
  createdAt: timestamp
  employee: employee_obj_rel_insert_input
  employeeId: uuid
  endTime: timestamp
  id: uuid
  organizationId: uuid
  startTime: timestamp
  tenantId: uuid
  type: String
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type availability_slot_max_fields {
  createdAt: timestamp
  employeeId: uuid
  endTime: timestamp
  id: uuid
  organizationId: uuid
  startTime: timestamp
  tenantId: uuid
  type: String
  updatedAt: timestamp
}

"""
order by max() on columns of table "availability_slot"
"""
input availability_slot_max_order_by {
  createdAt: order_by
  employeeId: order_by
  endTime: order_by
  id: order_by
  organizationId: order_by
  startTime: order_by
  tenantId: order_by
  type: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type availability_slot_min_fields {
  createdAt: timestamp
  employeeId: uuid
  endTime: timestamp
  id: uuid
  organizationId: uuid
  startTime: timestamp
  tenantId: uuid
  type: String
  updatedAt: timestamp
}

"""
order by min() on columns of table "availability_slot"
"""
input availability_slot_min_order_by {
  createdAt: order_by
  employeeId: order_by
  endTime: order_by
  id: order_by
  organizationId: order_by
  startTime: order_by
  tenantId: order_by
  type: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "availability_slot"
"""
type availability_slot_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [availability_slot!]!
}

"""
input type for inserting object relation for remote table "availability_slot"
"""
input availability_slot_obj_rel_insert_input {
  data: availability_slot_insert_input!
  on_conflict: availability_slot_on_conflict
}

"""
on conflict condition type for table "availability_slot"
"""
input availability_slot_on_conflict {
  constraint: availability_slot_constraint!
  update_columns: [availability_slot_update_column!]!
  where: availability_slot_bool_exp
}

"""
ordering options when selecting data from "availability_slot"
"""
input availability_slot_order_by {
  allDay: order_by
  createdAt: order_by
  employee: employee_order_by
  employeeId: order_by
  endTime: order_by
  id: order_by
  organizationId: order_by
  startTime: order_by
  tenantId: order_by
  type: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "availability_slot"
"""
input availability_slot_pk_columns_input {
  id: uuid!
}

"""
select columns of table "availability_slot"
"""
enum availability_slot_select_column {
  """
  column name
  """
  allDay

  """
  column name
  """
  createdAt

  """
  column name
  """
  employeeId

  """
  column name
  """
  endTime

  """
  column name
  """
  id

  """
  column name
  """
  organizationId

  """
  column name
  """
  startTime

  """
  column name
  """
  tenantId

  """
  column name
  """
  type

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "availability_slot"
"""
input availability_slot_set_input {
  allDay: Boolean
  createdAt: timestamp
  employeeId: uuid
  endTime: timestamp
  id: uuid
  organizationId: uuid
  startTime: timestamp
  tenantId: uuid
  type: String
  updatedAt: timestamp
}

"""
update columns of table "availability_slot"
"""
enum availability_slot_update_column {
  """
  column name
  """
  allDay

  """
  column name
  """
  createdAt

  """
  column name
  """
  employeeId

  """
  column name
  """
  endTime

  """
  column name
  """
  id

  """
  column name
  """
  organizationId

  """
  column name
  """
  startTime

  """
  column name
  """
  tenantId

  """
  column name
  """
  type

  """
  column name
  """
  updatedAt
}

"""
columns and relationships of "contact"
"""
type contact {
  address: String
  address2: String
  city: String
  country: String
  createdAt: timestamp!

  """
  An array relationship
  """
  employees(
    """
    distinct select on columns
    """
    distinct_on: [employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_order_by!]

    """
    filter the rows returned
    """
    where: employee_bool_exp
  ): [employee!]!

  """
  An aggregated array relationship
  """
  employees_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_order_by!]

    """
    filter the rows returned
    """
    where: employee_bool_exp
  ): employee_aggregate!
  fax: String
  firstName: String
  fiscalInformation: String
  id: uuid!
  lastName: String
  name: String
  organizationId: uuid
  postcode: Int
  regionCode: String
  tenantId: uuid
  updatedAt: timestamp!
  website: String
}

"""
aggregated selection of "contact"
"""
type contact_aggregate {
  aggregate: contact_aggregate_fields
  nodes: [contact!]!
}

"""
aggregate fields of "contact"
"""
type contact_aggregate_fields {
  avg: contact_avg_fields
  count(columns: [contact_select_column!], distinct: Boolean): Int
  max: contact_max_fields
  min: contact_min_fields
  stddev: contact_stddev_fields
  stddev_pop: contact_stddev_pop_fields
  stddev_samp: contact_stddev_samp_fields
  sum: contact_sum_fields
  var_pop: contact_var_pop_fields
  var_samp: contact_var_samp_fields
  variance: contact_variance_fields
}

"""
order by aggregate values of table "contact"
"""
input contact_aggregate_order_by {
  avg: contact_avg_order_by
  count: order_by
  max: contact_max_order_by
  min: contact_min_order_by
  stddev: contact_stddev_order_by
  stddev_pop: contact_stddev_pop_order_by
  stddev_samp: contact_stddev_samp_order_by
  sum: contact_sum_order_by
  var_pop: contact_var_pop_order_by
  var_samp: contact_var_samp_order_by
  variance: contact_variance_order_by
}

"""
input type for inserting array relation for remote table "contact"
"""
input contact_arr_rel_insert_input {
  data: [contact_insert_input!]!
  on_conflict: contact_on_conflict
}

"""
aggregate avg on columns
"""
type contact_avg_fields {
  postcode: Float
}

"""
order by avg() on columns of table "contact"
"""
input contact_avg_order_by {
  postcode: order_by
}

"""
Boolean expression to filter rows from the table "contact". All fields are combined with a logical 'AND'.
"""
input contact_bool_exp {
  _and: [contact_bool_exp]
  _not: contact_bool_exp
  _or: [contact_bool_exp]
  address: String_comparison_exp
  address2: String_comparison_exp
  city: String_comparison_exp
  country: String_comparison_exp
  createdAt: timestamp_comparison_exp
  employees: employee_bool_exp
  fax: String_comparison_exp
  firstName: String_comparison_exp
  fiscalInformation: String_comparison_exp
  id: uuid_comparison_exp
  lastName: String_comparison_exp
  name: String_comparison_exp
  organizationId: uuid_comparison_exp
  postcode: Int_comparison_exp
  regionCode: String_comparison_exp
  tenantId: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "contact"
"""
enum contact_constraint {
  """
  unique or primary key constraint
  """
  PK_2cbbe00f59ab6b3bb5b8d19f989
}

"""
input type for incrementing integer column in table "contact"
"""
input contact_inc_input {
  postcode: Int
}

"""
input type for inserting data into table "contact"
"""
input contact_insert_input {
  address: String
  address2: String
  city: String
  country: String
  createdAt: timestamp
  employees: employee_arr_rel_insert_input
  fax: String
  firstName: String
  fiscalInformation: String
  id: uuid
  lastName: String
  name: String
  organizationId: uuid
  postcode: Int
  regionCode: String
  tenantId: uuid
  updatedAt: timestamp
  website: String
}

"""
aggregate max on columns
"""
type contact_max_fields {
  address: String
  address2: String
  city: String
  country: String
  createdAt: timestamp
  fax: String
  firstName: String
  fiscalInformation: String
  id: uuid
  lastName: String
  name: String
  organizationId: uuid
  postcode: Int
  regionCode: String
  tenantId: uuid
  updatedAt: timestamp
  website: String
}

"""
order by max() on columns of table "contact"
"""
input contact_max_order_by {
  address: order_by
  address2: order_by
  city: order_by
  country: order_by
  createdAt: order_by
  fax: order_by
  firstName: order_by
  fiscalInformation: order_by
  id: order_by
  lastName: order_by
  name: order_by
  organizationId: order_by
  postcode: order_by
  regionCode: order_by
  tenantId: order_by
  updatedAt: order_by
  website: order_by
}

"""
aggregate min on columns
"""
type contact_min_fields {
  address: String
  address2: String
  city: String
  country: String
  createdAt: timestamp
  fax: String
  firstName: String
  fiscalInformation: String
  id: uuid
  lastName: String
  name: String
  organizationId: uuid
  postcode: Int
  regionCode: String
  tenantId: uuid
  updatedAt: timestamp
  website: String
}

"""
order by min() on columns of table "contact"
"""
input contact_min_order_by {
  address: order_by
  address2: order_by
  city: order_by
  country: order_by
  createdAt: order_by
  fax: order_by
  firstName: order_by
  fiscalInformation: order_by
  id: order_by
  lastName: order_by
  name: order_by
  organizationId: order_by
  postcode: order_by
  regionCode: order_by
  tenantId: order_by
  updatedAt: order_by
  website: order_by
}

"""
response of any mutation on the table "contact"
"""
type contact_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [contact!]!
}

"""
input type for inserting object relation for remote table "contact"
"""
input contact_obj_rel_insert_input {
  data: contact_insert_input!
  on_conflict: contact_on_conflict
}

"""
on conflict condition type for table "contact"
"""
input contact_on_conflict {
  constraint: contact_constraint!
  update_columns: [contact_update_column!]!
  where: contact_bool_exp
}

"""
ordering options when selecting data from "contact"
"""
input contact_order_by {
  address: order_by
  address2: order_by
  city: order_by
  country: order_by
  createdAt: order_by
  employees_aggregate: employee_aggregate_order_by
  fax: order_by
  firstName: order_by
  fiscalInformation: order_by
  id: order_by
  lastName: order_by
  name: order_by
  organizationId: order_by
  postcode: order_by
  regionCode: order_by
  tenantId: order_by
  updatedAt: order_by
  website: order_by
}

"""
primary key columns input for table: "contact"
"""
input contact_pk_columns_input {
  id: uuid!
}

"""
select columns of table "contact"
"""
enum contact_select_column {
  """
  column name
  """
  address

  """
  column name
  """
  address2

  """
  column name
  """
  city

  """
  column name
  """
  country

  """
  column name
  """
  createdAt

  """
  column name
  """
  fax

  """
  column name
  """
  firstName

  """
  column name
  """
  fiscalInformation

  """
  column name
  """
  id

  """
  column name
  """
  lastName

  """
  column name
  """
  name

  """
  column name
  """
  organizationId

  """
  column name
  """
  postcode

  """
  column name
  """
  regionCode

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  website
}

"""
input type for updating data in table "contact"
"""
input contact_set_input {
  address: String
  address2: String
  city: String
  country: String
  createdAt: timestamp
  fax: String
  firstName: String
  fiscalInformation: String
  id: uuid
  lastName: String
  name: String
  organizationId: uuid
  postcode: Int
  regionCode: String
  tenantId: uuid
  updatedAt: timestamp
  website: String
}

"""
aggregate stddev on columns
"""
type contact_stddev_fields {
  postcode: Float
}

"""
order by stddev() on columns of table "contact"
"""
input contact_stddev_order_by {
  postcode: order_by
}

"""
aggregate stddev_pop on columns
"""
type contact_stddev_pop_fields {
  postcode: Float
}

"""
order by stddev_pop() on columns of table "contact"
"""
input contact_stddev_pop_order_by {
  postcode: order_by
}

"""
aggregate stddev_samp on columns
"""
type contact_stddev_samp_fields {
  postcode: Float
}

"""
order by stddev_samp() on columns of table "contact"
"""
input contact_stddev_samp_order_by {
  postcode: order_by
}

"""
aggregate sum on columns
"""
type contact_sum_fields {
  postcode: Int
}

"""
order by sum() on columns of table "contact"
"""
input contact_sum_order_by {
  postcode: order_by
}

"""
update columns of table "contact"
"""
enum contact_update_column {
  """
  column name
  """
  address

  """
  column name
  """
  address2

  """
  column name
  """
  city

  """
  column name
  """
  country

  """
  column name
  """
  createdAt

  """
  column name
  """
  fax

  """
  column name
  """
  firstName

  """
  column name
  """
  fiscalInformation

  """
  column name
  """
  id

  """
  column name
  """
  lastName

  """
  column name
  """
  name

  """
  column name
  """
  organizationId

  """
  column name
  """
  postcode

  """
  column name
  """
  regionCode

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  website
}

"""
aggregate var_pop on columns
"""
type contact_var_pop_fields {
  postcode: Float
}

"""
order by var_pop() on columns of table "contact"
"""
input contact_var_pop_order_by {
  postcode: order_by
}

"""
aggregate var_samp on columns
"""
type contact_var_samp_fields {
  postcode: Float
}

"""
order by var_samp() on columns of table "contact"
"""
input contact_var_samp_order_by {
  postcode: order_by
}

"""
aggregate variance on columns
"""
type contact_variance_fields {
  postcode: Float
}

"""
order by variance() on columns of table "contact"
"""
input contact_variance_order_by {
  postcode: order_by
}

scalar date

"""
expression to compare columns of type date. All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "employee"
"""
type employee {
  acceptDate: timestamp

  """
  An array relationship
  """
  activities(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): [activity!]!

  """
  An aggregated array relationship
  """
  activities_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): activity_aggregate!
  anonymousBonus: Boolean

  """
  An array relationship
  """
  availability_slots(
    """
    distinct select on columns
    """
    distinct_on: [availability_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [availability_slot_order_by!]

    """
    filter the rows returned
    """
    where: availability_slot_bool_exp
  ): [availability_slot!]!

  """
  An aggregated array relationship
  """
  availability_slots_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [availability_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [availability_slot_order_by!]

    """
    filter the rows returned
    """
    where: availability_slot_bool_exp
  ): availability_slot_aggregate!
  averageBonus: numeric
  averageExpenses: numeric
  averageIncome: numeric
  billRateCurrency: String
  billRateValue: numeric

  """
  An object relationship
  """
  contact: contact
  contactId: uuid
  createdAt: timestamp!
  description: String
  employeeLevel: String

  """
  An array relationship
  """
  employee_appointments(
    """
    distinct select on columns
    """
    distinct_on: [employee_appointment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_appointment_order_by!]

    """
    filter the rows returned
    """
    where: employee_appointment_bool_exp
  ): [employee_appointment!]!

  """
  An aggregated array relationship
  """
  employee_appointments_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [employee_appointment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_appointment_order_by!]

    """
    filter the rows returned
    """
    where: employee_appointment_bool_exp
  ): employee_appointment_aggregate!
  endWork: timestamp

  """
  An array relationship
  """
  event_types(
    """
    distinct select on columns
    """
    distinct_on: [event_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [event_type_order_by!]

    """
    filter the rows returned
    """
    where: event_type_bool_exp
  ): [event_type!]!

  """
  An aggregated array relationship
  """
  event_types_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [event_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [event_type_order_by!]

    """
    filter the rows returned
    """
    where: event_type_bool_exp
  ): event_type_aggregate!
  id: uuid!
  isActive: Boolean
  offerDate: timestamp
  organizationId: uuid
  organizationPositionId: uuid
  payPeriod: String
  reWeeklyLimit: Int
  rejectDate: timestamp
  short_description: String
  show_anonymous_bonus: Boolean
  show_average_bonus: Boolean
  show_average_expenses: Boolean
  show_average_income: Boolean
  show_billrate: Boolean
  show_payperiod: Boolean
  show_start_work_on: Boolean
  startedWorkOn: timestamp
  tenantId: uuid

  """
  An array relationship
  """
  time_logs(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): [time_log!]!

  """
  An aggregated array relationship
  """
  time_logs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): time_log_aggregate!

  """
  An array relationship
  """
  time_slots(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_bool_exp
  ): [time_slot!]!

  """
  An aggregated array relationship
  """
  time_slots_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_bool_exp
  ): time_slot_aggregate!

  """
  An array relationship
  """
  timesheets(
    """
    distinct select on columns
    """
    distinct_on: [timesheet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timesheet_order_by!]

    """
    filter the rows returned
    """
    where: timesheet_bool_exp
  ): [timesheet!]!

  """
  An array relationship
  """
  timesheetsByApprovedbyid(
    """
    distinct select on columns
    """
    distinct_on: [timesheet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timesheet_order_by!]

    """
    filter the rows returned
    """
    where: timesheet_bool_exp
  ): [timesheet!]!

  """
  An aggregated array relationship
  """
  timesheetsByApprovedbyid_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timesheet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timesheet_order_by!]

    """
    filter the rows returned
    """
    where: timesheet_bool_exp
  ): timesheet_aggregate!

  """
  An aggregated array relationship
  """
  timesheets_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timesheet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timesheet_order_by!]

    """
    filter the rows returned
    """
    where: timesheet_bool_exp
  ): timesheet_aggregate!
  totalWorkHours: numeric!
  updatedAt: timestamp!

  """
  An object relationship
  """
  user: user!
  userId: uuid!
  valueDate: timestamp
}

"""
aggregated selection of "employee"
"""
type employee_aggregate {
  aggregate: employee_aggregate_fields
  nodes: [employee!]!
}

"""
aggregate fields of "employee"
"""
type employee_aggregate_fields {
  avg: employee_avg_fields
  count(columns: [employee_select_column!], distinct: Boolean): Int
  max: employee_max_fields
  min: employee_min_fields
  stddev: employee_stddev_fields
  stddev_pop: employee_stddev_pop_fields
  stddev_samp: employee_stddev_samp_fields
  sum: employee_sum_fields
  var_pop: employee_var_pop_fields
  var_samp: employee_var_samp_fields
  variance: employee_variance_fields
}

"""
order by aggregate values of table "employee"
"""
input employee_aggregate_order_by {
  avg: employee_avg_order_by
  count: order_by
  max: employee_max_order_by
  min: employee_min_order_by
  stddev: employee_stddev_order_by
  stddev_pop: employee_stddev_pop_order_by
  stddev_samp: employee_stddev_samp_order_by
  sum: employee_sum_order_by
  var_pop: employee_var_pop_order_by
  var_samp: employee_var_samp_order_by
  variance: employee_variance_order_by
}

"""
columns and relationships of "employee_appointment"
"""
type employee_appointment {
  agenda: String!

  """
  An array relationship
  """
  appointment_employees(
    """
    distinct select on columns
    """
    distinct_on: [appointment_employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [appointment_employee_order_by!]

    """
    filter the rows returned
    """
    where: appointment_employee_bool_exp
  ): [appointment_employee!]!

  """
  An aggregated array relationship
  """
  appointment_employees_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [appointment_employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [appointment_employee_order_by!]

    """
    filter the rows returned
    """
    where: appointment_employee_bool_exp
  ): appointment_employee_aggregate!
  breakStartTime: timestamp
  breakTimeInMins: Int
  bufferTimeEnd: Boolean
  bufferTimeInMins: Int
  bufferTimeStart: Boolean
  createdAt: timestamp!
  description: String
  emails: String

  """
  An object relationship
  """
  employee: employee
  employeeId: uuid
  endDateTime: timestamp!
  id: uuid!
  location: String
  organizationId: uuid
  startDateTime: timestamp!
  status: String
  tenantId: uuid
  updatedAt: timestamp!
}

"""
aggregated selection of "employee_appointment"
"""
type employee_appointment_aggregate {
  aggregate: employee_appointment_aggregate_fields
  nodes: [employee_appointment!]!
}

"""
aggregate fields of "employee_appointment"
"""
type employee_appointment_aggregate_fields {
  avg: employee_appointment_avg_fields
  count(columns: [employee_appointment_select_column!], distinct: Boolean): Int
  max: employee_appointment_max_fields
  min: employee_appointment_min_fields
  stddev: employee_appointment_stddev_fields
  stddev_pop: employee_appointment_stddev_pop_fields
  stddev_samp: employee_appointment_stddev_samp_fields
  sum: employee_appointment_sum_fields
  var_pop: employee_appointment_var_pop_fields
  var_samp: employee_appointment_var_samp_fields
  variance: employee_appointment_variance_fields
}

"""
order by aggregate values of table "employee_appointment"
"""
input employee_appointment_aggregate_order_by {
  avg: employee_appointment_avg_order_by
  count: order_by
  max: employee_appointment_max_order_by
  min: employee_appointment_min_order_by
  stddev: employee_appointment_stddev_order_by
  stddev_pop: employee_appointment_stddev_pop_order_by
  stddev_samp: employee_appointment_stddev_samp_order_by
  sum: employee_appointment_sum_order_by
  var_pop: employee_appointment_var_pop_order_by
  var_samp: employee_appointment_var_samp_order_by
  variance: employee_appointment_variance_order_by
}

"""
input type for inserting array relation for remote table "employee_appointment"
"""
input employee_appointment_arr_rel_insert_input {
  data: [employee_appointment_insert_input!]!
  on_conflict: employee_appointment_on_conflict
}

"""
aggregate avg on columns
"""
type employee_appointment_avg_fields {
  breakTimeInMins: Float
  bufferTimeInMins: Float
}

"""
order by avg() on columns of table "employee_appointment"
"""
input employee_appointment_avg_order_by {
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
}

"""
Boolean expression to filter rows from the table "employee_appointment". All fields are combined with a logical 'AND'.
"""
input employee_appointment_bool_exp {
  _and: [employee_appointment_bool_exp]
  _not: employee_appointment_bool_exp
  _or: [employee_appointment_bool_exp]
  agenda: String_comparison_exp
  appointment_employees: appointment_employee_bool_exp
  breakStartTime: timestamp_comparison_exp
  breakTimeInMins: Int_comparison_exp
  bufferTimeEnd: Boolean_comparison_exp
  bufferTimeInMins: Int_comparison_exp
  bufferTimeStart: Boolean_comparison_exp
  createdAt: timestamp_comparison_exp
  description: String_comparison_exp
  emails: String_comparison_exp
  employee: employee_bool_exp
  employeeId: uuid_comparison_exp
  endDateTime: timestamp_comparison_exp
  id: uuid_comparison_exp
  location: String_comparison_exp
  organizationId: uuid_comparison_exp
  startDateTime: timestamp_comparison_exp
  status: String_comparison_exp
  tenantId: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "employee_appointment"
"""
enum employee_appointment_constraint {
  """
  unique or primary key constraint
  """
  PK_0cffa7fe7917dce7981f126e8bc
}

"""
input type for incrementing integer column in table "employee_appointment"
"""
input employee_appointment_inc_input {
  breakTimeInMins: Int
  bufferTimeInMins: Int
}

"""
input type for inserting data into table "employee_appointment"
"""
input employee_appointment_insert_input {
  agenda: String
  appointment_employees: appointment_employee_arr_rel_insert_input
  breakStartTime: timestamp
  breakTimeInMins: Int
  bufferTimeEnd: Boolean
  bufferTimeInMins: Int
  bufferTimeStart: Boolean
  createdAt: timestamp
  description: String
  emails: String
  employee: employee_obj_rel_insert_input
  employeeId: uuid
  endDateTime: timestamp
  id: uuid
  location: String
  organizationId: uuid
  startDateTime: timestamp
  status: String
  tenantId: uuid
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type employee_appointment_max_fields {
  agenda: String
  breakStartTime: timestamp
  breakTimeInMins: Int
  bufferTimeInMins: Int
  createdAt: timestamp
  description: String
  emails: String
  employeeId: uuid
  endDateTime: timestamp
  id: uuid
  location: String
  organizationId: uuid
  startDateTime: timestamp
  status: String
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by max() on columns of table "employee_appointment"
"""
input employee_appointment_max_order_by {
  agenda: order_by
  breakStartTime: order_by
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
  createdAt: order_by
  description: order_by
  emails: order_by
  employeeId: order_by
  endDateTime: order_by
  id: order_by
  location: order_by
  organizationId: order_by
  startDateTime: order_by
  status: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type employee_appointment_min_fields {
  agenda: String
  breakStartTime: timestamp
  breakTimeInMins: Int
  bufferTimeInMins: Int
  createdAt: timestamp
  description: String
  emails: String
  employeeId: uuid
  endDateTime: timestamp
  id: uuid
  location: String
  organizationId: uuid
  startDateTime: timestamp
  status: String
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by min() on columns of table "employee_appointment"
"""
input employee_appointment_min_order_by {
  agenda: order_by
  breakStartTime: order_by
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
  createdAt: order_by
  description: order_by
  emails: order_by
  employeeId: order_by
  endDateTime: order_by
  id: order_by
  location: order_by
  organizationId: order_by
  startDateTime: order_by
  status: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "employee_appointment"
"""
type employee_appointment_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [employee_appointment!]!
}

"""
input type for inserting object relation for remote table "employee_appointment"
"""
input employee_appointment_obj_rel_insert_input {
  data: employee_appointment_insert_input!
  on_conflict: employee_appointment_on_conflict
}

"""
on conflict condition type for table "employee_appointment"
"""
input employee_appointment_on_conflict {
  constraint: employee_appointment_constraint!
  update_columns: [employee_appointment_update_column!]!
  where: employee_appointment_bool_exp
}

"""
ordering options when selecting data from "employee_appointment"
"""
input employee_appointment_order_by {
  agenda: order_by
  appointment_employees_aggregate: appointment_employee_aggregate_order_by
  breakStartTime: order_by
  breakTimeInMins: order_by
  bufferTimeEnd: order_by
  bufferTimeInMins: order_by
  bufferTimeStart: order_by
  createdAt: order_by
  description: order_by
  emails: order_by
  employee: employee_order_by
  employeeId: order_by
  endDateTime: order_by
  id: order_by
  location: order_by
  organizationId: order_by
  startDateTime: order_by
  status: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "employee_appointment"
"""
input employee_appointment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee_appointment"
"""
enum employee_appointment_select_column {
  """
  column name
  """
  agenda

  """
  column name
  """
  breakStartTime

  """
  column name
  """
  breakTimeInMins

  """
  column name
  """
  bufferTimeEnd

  """
  column name
  """
  bufferTimeInMins

  """
  column name
  """
  bufferTimeStart

  """
  column name
  """
  createdAt

  """
  column name
  """
  description

  """
  column name
  """
  emails

  """
  column name
  """
  employeeId

  """
  column name
  """
  endDateTime

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  organizationId

  """
  column name
  """
  startDateTime

  """
  column name
  """
  status

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "employee_appointment"
"""
input employee_appointment_set_input {
  agenda: String
  breakStartTime: timestamp
  breakTimeInMins: Int
  bufferTimeEnd: Boolean
  bufferTimeInMins: Int
  bufferTimeStart: Boolean
  createdAt: timestamp
  description: String
  emails: String
  employeeId: uuid
  endDateTime: timestamp
  id: uuid
  location: String
  organizationId: uuid
  startDateTime: timestamp
  status: String
  tenantId: uuid
  updatedAt: timestamp
}

"""
aggregate stddev on columns
"""
type employee_appointment_stddev_fields {
  breakTimeInMins: Float
  bufferTimeInMins: Float
}

"""
order by stddev() on columns of table "employee_appointment"
"""
input employee_appointment_stddev_order_by {
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
}

"""
aggregate stddev_pop on columns
"""
type employee_appointment_stddev_pop_fields {
  breakTimeInMins: Float
  bufferTimeInMins: Float
}

"""
order by stddev_pop() on columns of table "employee_appointment"
"""
input employee_appointment_stddev_pop_order_by {
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
}

"""
aggregate stddev_samp on columns
"""
type employee_appointment_stddev_samp_fields {
  breakTimeInMins: Float
  bufferTimeInMins: Float
}

"""
order by stddev_samp() on columns of table "employee_appointment"
"""
input employee_appointment_stddev_samp_order_by {
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
}

"""
aggregate sum on columns
"""
type employee_appointment_sum_fields {
  breakTimeInMins: Int
  bufferTimeInMins: Int
}

"""
order by sum() on columns of table "employee_appointment"
"""
input employee_appointment_sum_order_by {
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
}

"""
update columns of table "employee_appointment"
"""
enum employee_appointment_update_column {
  """
  column name
  """
  agenda

  """
  column name
  """
  breakStartTime

  """
  column name
  """
  breakTimeInMins

  """
  column name
  """
  bufferTimeEnd

  """
  column name
  """
  bufferTimeInMins

  """
  column name
  """
  bufferTimeStart

  """
  column name
  """
  createdAt

  """
  column name
  """
  description

  """
  column name
  """
  emails

  """
  column name
  """
  employeeId

  """
  column name
  """
  endDateTime

  """
  column name
  """
  id

  """
  column name
  """
  location

  """
  column name
  """
  organizationId

  """
  column name
  """
  startDateTime

  """
  column name
  """
  status

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
aggregate var_pop on columns
"""
type employee_appointment_var_pop_fields {
  breakTimeInMins: Float
  bufferTimeInMins: Float
}

"""
order by var_pop() on columns of table "employee_appointment"
"""
input employee_appointment_var_pop_order_by {
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
}

"""
aggregate var_samp on columns
"""
type employee_appointment_var_samp_fields {
  breakTimeInMins: Float
  bufferTimeInMins: Float
}

"""
order by var_samp() on columns of table "employee_appointment"
"""
input employee_appointment_var_samp_order_by {
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
}

"""
aggregate variance on columns
"""
type employee_appointment_variance_fields {
  breakTimeInMins: Float
  bufferTimeInMins: Float
}

"""
order by variance() on columns of table "employee_appointment"
"""
input employee_appointment_variance_order_by {
  breakTimeInMins: order_by
  bufferTimeInMins: order_by
}

"""
input type for inserting array relation for remote table "employee"
"""
input employee_arr_rel_insert_input {
  data: [employee_insert_input!]!
  on_conflict: employee_on_conflict
}

"""
aggregate avg on columns
"""
type employee_avg_fields {
  averageBonus: Float
  averageExpenses: Float
  averageIncome: Float
  billRateValue: Float
  reWeeklyLimit: Float
  totalWorkHours: Float
}

"""
order by avg() on columns of table "employee"
"""
input employee_avg_order_by {
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateValue: order_by
  reWeeklyLimit: order_by
  totalWorkHours: order_by
}

"""
Boolean expression to filter rows from the table "employee". All fields are combined with a logical 'AND'.
"""
input employee_bool_exp {
  _and: [employee_bool_exp]
  _not: employee_bool_exp
  _or: [employee_bool_exp]
  acceptDate: timestamp_comparison_exp
  activities: activity_bool_exp
  anonymousBonus: Boolean_comparison_exp
  availability_slots: availability_slot_bool_exp
  averageBonus: numeric_comparison_exp
  averageExpenses: numeric_comparison_exp
  averageIncome: numeric_comparison_exp
  billRateCurrency: String_comparison_exp
  billRateValue: numeric_comparison_exp
  contact: contact_bool_exp
  contactId: uuid_comparison_exp
  createdAt: timestamp_comparison_exp
  description: String_comparison_exp
  employeeLevel: String_comparison_exp
  employee_appointments: employee_appointment_bool_exp
  endWork: timestamp_comparison_exp
  event_types: event_type_bool_exp
  id: uuid_comparison_exp
  isActive: Boolean_comparison_exp
  offerDate: timestamp_comparison_exp
  organizationId: uuid_comparison_exp
  organizationPositionId: uuid_comparison_exp
  payPeriod: String_comparison_exp
  reWeeklyLimit: Int_comparison_exp
  rejectDate: timestamp_comparison_exp
  short_description: String_comparison_exp
  show_anonymous_bonus: Boolean_comparison_exp
  show_average_bonus: Boolean_comparison_exp
  show_average_expenses: Boolean_comparison_exp
  show_average_income: Boolean_comparison_exp
  show_billrate: Boolean_comparison_exp
  show_payperiod: Boolean_comparison_exp
  show_start_work_on: Boolean_comparison_exp
  startedWorkOn: timestamp_comparison_exp
  tenantId: uuid_comparison_exp
  time_logs: time_log_bool_exp
  time_slots: time_slot_bool_exp
  timesheets: timesheet_bool_exp
  timesheetsByApprovedbyid: timesheet_bool_exp
  totalWorkHours: numeric_comparison_exp
  updatedAt: timestamp_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
  valueDate: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "employee"
"""
enum employee_constraint {
  """
  unique or primary key constraint
  """
  PK_3c2bc72f03fd5abbbc5ac169498

  """
  unique or primary key constraint
  """
  REL_f4b0d329c4a3cf79ffe9d56504
}

"""
input type for incrementing integer column in table "employee"
"""
input employee_inc_input {
  averageBonus: numeric
  averageExpenses: numeric
  averageIncome: numeric
  billRateValue: numeric
  reWeeklyLimit: Int
  totalWorkHours: numeric
}

"""
input type for inserting data into table "employee"
"""
input employee_insert_input {
  acceptDate: timestamp
  activities: activity_arr_rel_insert_input
  anonymousBonus: Boolean
  availability_slots: availability_slot_arr_rel_insert_input
  averageBonus: numeric
  averageExpenses: numeric
  averageIncome: numeric
  billRateCurrency: String
  billRateValue: numeric
  contact: contact_obj_rel_insert_input
  contactId: uuid
  createdAt: timestamp
  description: String
  employeeLevel: String
  employee_appointments: employee_appointment_arr_rel_insert_input
  endWork: timestamp
  event_types: event_type_arr_rel_insert_input
  id: uuid
  isActive: Boolean
  offerDate: timestamp
  organizationId: uuid
  organizationPositionId: uuid
  payPeriod: String
  reWeeklyLimit: Int
  rejectDate: timestamp
  short_description: String
  show_anonymous_bonus: Boolean
  show_average_bonus: Boolean
  show_average_expenses: Boolean
  show_average_income: Boolean
  show_billrate: Boolean
  show_payperiod: Boolean
  show_start_work_on: Boolean
  startedWorkOn: timestamp
  tenantId: uuid
  time_logs: time_log_arr_rel_insert_input
  time_slots: time_slot_arr_rel_insert_input
  timesheets: timesheet_arr_rel_insert_input
  timesheetsByApprovedbyid: timesheet_arr_rel_insert_input
  totalWorkHours: numeric
  updatedAt: timestamp
  user: user_obj_rel_insert_input
  userId: uuid
  valueDate: timestamp
}

"""
aggregate max on columns
"""
type employee_max_fields {
  acceptDate: timestamp
  averageBonus: numeric
  averageExpenses: numeric
  averageIncome: numeric
  billRateCurrency: String
  billRateValue: numeric
  contactId: uuid
  createdAt: timestamp
  description: String
  employeeLevel: String
  endWork: timestamp
  id: uuid
  offerDate: timestamp
  organizationId: uuid
  organizationPositionId: uuid
  payPeriod: String
  reWeeklyLimit: Int
  rejectDate: timestamp
  short_description: String
  startedWorkOn: timestamp
  tenantId: uuid
  totalWorkHours: numeric
  updatedAt: timestamp
  userId: uuid
  valueDate: timestamp
}

"""
order by max() on columns of table "employee"
"""
input employee_max_order_by {
  acceptDate: order_by
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateCurrency: order_by
  billRateValue: order_by
  contactId: order_by
  createdAt: order_by
  description: order_by
  employeeLevel: order_by
  endWork: order_by
  id: order_by
  offerDate: order_by
  organizationId: order_by
  organizationPositionId: order_by
  payPeriod: order_by
  reWeeklyLimit: order_by
  rejectDate: order_by
  short_description: order_by
  startedWorkOn: order_by
  tenantId: order_by
  totalWorkHours: order_by
  updatedAt: order_by
  userId: order_by
  valueDate: order_by
}

"""
aggregate min on columns
"""
type employee_min_fields {
  acceptDate: timestamp
  averageBonus: numeric
  averageExpenses: numeric
  averageIncome: numeric
  billRateCurrency: String
  billRateValue: numeric
  contactId: uuid
  createdAt: timestamp
  description: String
  employeeLevel: String
  endWork: timestamp
  id: uuid
  offerDate: timestamp
  organizationId: uuid
  organizationPositionId: uuid
  payPeriod: String
  reWeeklyLimit: Int
  rejectDate: timestamp
  short_description: String
  startedWorkOn: timestamp
  tenantId: uuid
  totalWorkHours: numeric
  updatedAt: timestamp
  userId: uuid
  valueDate: timestamp
}

"""
order by min() on columns of table "employee"
"""
input employee_min_order_by {
  acceptDate: order_by
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateCurrency: order_by
  billRateValue: order_by
  contactId: order_by
  createdAt: order_by
  description: order_by
  employeeLevel: order_by
  endWork: order_by
  id: order_by
  offerDate: order_by
  organizationId: order_by
  organizationPositionId: order_by
  payPeriod: order_by
  reWeeklyLimit: order_by
  rejectDate: order_by
  short_description: order_by
  startedWorkOn: order_by
  tenantId: order_by
  totalWorkHours: order_by
  updatedAt: order_by
  userId: order_by
  valueDate: order_by
}

"""
response of any mutation on the table "employee"
"""
type employee_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [employee!]!
}

"""
input type for inserting object relation for remote table "employee"
"""
input employee_obj_rel_insert_input {
  data: employee_insert_input!
  on_conflict: employee_on_conflict
}

"""
on conflict condition type for table "employee"
"""
input employee_on_conflict {
  constraint: employee_constraint!
  update_columns: [employee_update_column!]!
  where: employee_bool_exp
}

"""
ordering options when selecting data from "employee"
"""
input employee_order_by {
  acceptDate: order_by
  activities_aggregate: activity_aggregate_order_by
  anonymousBonus: order_by
  availability_slots_aggregate: availability_slot_aggregate_order_by
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateCurrency: order_by
  billRateValue: order_by
  contact: contact_order_by
  contactId: order_by
  createdAt: order_by
  description: order_by
  employeeLevel: order_by
  employee_appointments_aggregate: employee_appointment_aggregate_order_by
  endWork: order_by
  event_types_aggregate: event_type_aggregate_order_by
  id: order_by
  isActive: order_by
  offerDate: order_by
  organizationId: order_by
  organizationPositionId: order_by
  payPeriod: order_by
  reWeeklyLimit: order_by
  rejectDate: order_by
  short_description: order_by
  show_anonymous_bonus: order_by
  show_average_bonus: order_by
  show_average_expenses: order_by
  show_average_income: order_by
  show_billrate: order_by
  show_payperiod: order_by
  show_start_work_on: order_by
  startedWorkOn: order_by
  tenantId: order_by
  time_logs_aggregate: time_log_aggregate_order_by
  time_slots_aggregate: time_slot_aggregate_order_by
  timesheetsByApprovedbyid_aggregate: timesheet_aggregate_order_by
  timesheets_aggregate: timesheet_aggregate_order_by
  totalWorkHours: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
  valueDate: order_by
}

"""
primary key columns input for table: "employee"
"""
input employee_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employee"
"""
enum employee_select_column {
  """
  column name
  """
  acceptDate

  """
  column name
  """
  anonymousBonus

  """
  column name
  """
  averageBonus

  """
  column name
  """
  averageExpenses

  """
  column name
  """
  averageIncome

  """
  column name
  """
  billRateCurrency

  """
  column name
  """
  billRateValue

  """
  column name
  """
  contactId

  """
  column name
  """
  createdAt

  """
  column name
  """
  description

  """
  column name
  """
  employeeLevel

  """
  column name
  """
  endWork

  """
  column name
  """
  id

  """
  column name
  """
  isActive

  """
  column name
  """
  offerDate

  """
  column name
  """
  organizationId

  """
  column name
  """
  organizationPositionId

  """
  column name
  """
  payPeriod

  """
  column name
  """
  reWeeklyLimit

  """
  column name
  """
  rejectDate

  """
  column name
  """
  short_description

  """
  column name
  """
  show_anonymous_bonus

  """
  column name
  """
  show_average_bonus

  """
  column name
  """
  show_average_expenses

  """
  column name
  """
  show_average_income

  """
  column name
  """
  show_billrate

  """
  column name
  """
  show_payperiod

  """
  column name
  """
  show_start_work_on

  """
  column name
  """
  startedWorkOn

  """
  column name
  """
  tenantId

  """
  column name
  """
  totalWorkHours

  """
  column name
  """
  updatedAt

  """
  column name
  """
  userId

  """
  column name
  """
  valueDate
}

"""
input type for updating data in table "employee"
"""
input employee_set_input {
  acceptDate: timestamp
  anonymousBonus: Boolean
  averageBonus: numeric
  averageExpenses: numeric
  averageIncome: numeric
  billRateCurrency: String
  billRateValue: numeric
  contactId: uuid
  createdAt: timestamp
  description: String
  employeeLevel: String
  endWork: timestamp
  id: uuid
  isActive: Boolean
  offerDate: timestamp
  organizationId: uuid
  organizationPositionId: uuid
  payPeriod: String
  reWeeklyLimit: Int
  rejectDate: timestamp
  short_description: String
  show_anonymous_bonus: Boolean
  show_average_bonus: Boolean
  show_average_expenses: Boolean
  show_average_income: Boolean
  show_billrate: Boolean
  show_payperiod: Boolean
  show_start_work_on: Boolean
  startedWorkOn: timestamp
  tenantId: uuid
  totalWorkHours: numeric
  updatedAt: timestamp
  userId: uuid
  valueDate: timestamp
}

"""
aggregate stddev on columns
"""
type employee_stddev_fields {
  averageBonus: Float
  averageExpenses: Float
  averageIncome: Float
  billRateValue: Float
  reWeeklyLimit: Float
  totalWorkHours: Float
}

"""
order by stddev() on columns of table "employee"
"""
input employee_stddev_order_by {
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateValue: order_by
  reWeeklyLimit: order_by
  totalWorkHours: order_by
}

"""
aggregate stddev_pop on columns
"""
type employee_stddev_pop_fields {
  averageBonus: Float
  averageExpenses: Float
  averageIncome: Float
  billRateValue: Float
  reWeeklyLimit: Float
  totalWorkHours: Float
}

"""
order by stddev_pop() on columns of table "employee"
"""
input employee_stddev_pop_order_by {
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateValue: order_by
  reWeeklyLimit: order_by
  totalWorkHours: order_by
}

"""
aggregate stddev_samp on columns
"""
type employee_stddev_samp_fields {
  averageBonus: Float
  averageExpenses: Float
  averageIncome: Float
  billRateValue: Float
  reWeeklyLimit: Float
  totalWorkHours: Float
}

"""
order by stddev_samp() on columns of table "employee"
"""
input employee_stddev_samp_order_by {
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateValue: order_by
  reWeeklyLimit: order_by
  totalWorkHours: order_by
}

"""
aggregate sum on columns
"""
type employee_sum_fields {
  averageBonus: numeric
  averageExpenses: numeric
  averageIncome: numeric
  billRateValue: numeric
  reWeeklyLimit: Int
  totalWorkHours: numeric
}

"""
order by sum() on columns of table "employee"
"""
input employee_sum_order_by {
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateValue: order_by
  reWeeklyLimit: order_by
  totalWorkHours: order_by
}

"""
update columns of table "employee"
"""
enum employee_update_column {
  """
  column name
  """
  acceptDate

  """
  column name
  """
  anonymousBonus

  """
  column name
  """
  averageBonus

  """
  column name
  """
  averageExpenses

  """
  column name
  """
  averageIncome

  """
  column name
  """
  billRateCurrency

  """
  column name
  """
  billRateValue

  """
  column name
  """
  contactId

  """
  column name
  """
  createdAt

  """
  column name
  """
  description

  """
  column name
  """
  employeeLevel

  """
  column name
  """
  endWork

  """
  column name
  """
  id

  """
  column name
  """
  isActive

  """
  column name
  """
  offerDate

  """
  column name
  """
  organizationId

  """
  column name
  """
  organizationPositionId

  """
  column name
  """
  payPeriod

  """
  column name
  """
  reWeeklyLimit

  """
  column name
  """
  rejectDate

  """
  column name
  """
  short_description

  """
  column name
  """
  show_anonymous_bonus

  """
  column name
  """
  show_average_bonus

  """
  column name
  """
  show_average_expenses

  """
  column name
  """
  show_average_income

  """
  column name
  """
  show_billrate

  """
  column name
  """
  show_payperiod

  """
  column name
  """
  show_start_work_on

  """
  column name
  """
  startedWorkOn

  """
  column name
  """
  tenantId

  """
  column name
  """
  totalWorkHours

  """
  column name
  """
  updatedAt

  """
  column name
  """
  userId

  """
  column name
  """
  valueDate
}

"""
aggregate var_pop on columns
"""
type employee_var_pop_fields {
  averageBonus: Float
  averageExpenses: Float
  averageIncome: Float
  billRateValue: Float
  reWeeklyLimit: Float
  totalWorkHours: Float
}

"""
order by var_pop() on columns of table "employee"
"""
input employee_var_pop_order_by {
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateValue: order_by
  reWeeklyLimit: order_by
  totalWorkHours: order_by
}

"""
aggregate var_samp on columns
"""
type employee_var_samp_fields {
  averageBonus: Float
  averageExpenses: Float
  averageIncome: Float
  billRateValue: Float
  reWeeklyLimit: Float
  totalWorkHours: Float
}

"""
order by var_samp() on columns of table "employee"
"""
input employee_var_samp_order_by {
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateValue: order_by
  reWeeklyLimit: order_by
  totalWorkHours: order_by
}

"""
aggregate variance on columns
"""
type employee_variance_fields {
  averageBonus: Float
  averageExpenses: Float
  averageIncome: Float
  billRateValue: Float
  reWeeklyLimit: Float
  totalWorkHours: Float
}

"""
order by variance() on columns of table "employee"
"""
input employee_variance_order_by {
  averageBonus: order_by
  averageExpenses: order_by
  averageIncome: order_by
  billRateValue: order_by
  reWeeklyLimit: order_by
  totalWorkHours: order_by
}

"""
columns and relationships of "event_type"
"""
type event_type {
  createdAt: timestamp!
  description: String
  duration: numeric!
  durationUnit: String

  """
  An object relationship
  """
  employee: employee
  employeeId: uuid
  id: uuid!
  isActive: Boolean
  organizationId: uuid
  tenantId: uuid
  title: String
  updatedAt: timestamp!
}

"""
aggregated selection of "event_type"
"""
type event_type_aggregate {
  aggregate: event_type_aggregate_fields
  nodes: [event_type!]!
}

"""
aggregate fields of "event_type"
"""
type event_type_aggregate_fields {
  avg: event_type_avg_fields
  count(columns: [event_type_select_column!], distinct: Boolean): Int
  max: event_type_max_fields
  min: event_type_min_fields
  stddev: event_type_stddev_fields
  stddev_pop: event_type_stddev_pop_fields
  stddev_samp: event_type_stddev_samp_fields
  sum: event_type_sum_fields
  var_pop: event_type_var_pop_fields
  var_samp: event_type_var_samp_fields
  variance: event_type_variance_fields
}

"""
order by aggregate values of table "event_type"
"""
input event_type_aggregate_order_by {
  avg: event_type_avg_order_by
  count: order_by
  max: event_type_max_order_by
  min: event_type_min_order_by
  stddev: event_type_stddev_order_by
  stddev_pop: event_type_stddev_pop_order_by
  stddev_samp: event_type_stddev_samp_order_by
  sum: event_type_sum_order_by
  var_pop: event_type_var_pop_order_by
  var_samp: event_type_var_samp_order_by
  variance: event_type_variance_order_by
}

"""
input type for inserting array relation for remote table "event_type"
"""
input event_type_arr_rel_insert_input {
  data: [event_type_insert_input!]!
  on_conflict: event_type_on_conflict
}

"""
aggregate avg on columns
"""
type event_type_avg_fields {
  duration: Float
}

"""
order by avg() on columns of table "event_type"
"""
input event_type_avg_order_by {
  duration: order_by
}

"""
Boolean expression to filter rows from the table "event_type". All fields are combined with a logical 'AND'.
"""
input event_type_bool_exp {
  _and: [event_type_bool_exp]
  _not: event_type_bool_exp
  _or: [event_type_bool_exp]
  createdAt: timestamp_comparison_exp
  description: String_comparison_exp
  duration: numeric_comparison_exp
  durationUnit: String_comparison_exp
  employee: employee_bool_exp
  employeeId: uuid_comparison_exp
  id: uuid_comparison_exp
  isActive: Boolean_comparison_exp
  organizationId: uuid_comparison_exp
  tenantId: uuid_comparison_exp
  title: String_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "event_type"
"""
enum event_type_constraint {
  """
  unique or primary key constraint
  """
  PK_d968f34984d7d85d96f782872fe
}

"""
input type for incrementing integer column in table "event_type"
"""
input event_type_inc_input {
  duration: numeric
}

"""
input type for inserting data into table "event_type"
"""
input event_type_insert_input {
  createdAt: timestamp
  description: String
  duration: numeric
  durationUnit: String
  employee: employee_obj_rel_insert_input
  employeeId: uuid
  id: uuid
  isActive: Boolean
  organizationId: uuid
  tenantId: uuid
  title: String
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type event_type_max_fields {
  createdAt: timestamp
  description: String
  duration: numeric
  durationUnit: String
  employeeId: uuid
  id: uuid
  organizationId: uuid
  tenantId: uuid
  title: String
  updatedAt: timestamp
}

"""
order by max() on columns of table "event_type"
"""
input event_type_max_order_by {
  createdAt: order_by
  description: order_by
  duration: order_by
  durationUnit: order_by
  employeeId: order_by
  id: order_by
  organizationId: order_by
  tenantId: order_by
  title: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type event_type_min_fields {
  createdAt: timestamp
  description: String
  duration: numeric
  durationUnit: String
  employeeId: uuid
  id: uuid
  organizationId: uuid
  tenantId: uuid
  title: String
  updatedAt: timestamp
}

"""
order by min() on columns of table "event_type"
"""
input event_type_min_order_by {
  createdAt: order_by
  description: order_by
  duration: order_by
  durationUnit: order_by
  employeeId: order_by
  id: order_by
  organizationId: order_by
  tenantId: order_by
  title: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "event_type"
"""
type event_type_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [event_type!]!
}

"""
input type for inserting object relation for remote table "event_type"
"""
input event_type_obj_rel_insert_input {
  data: event_type_insert_input!
  on_conflict: event_type_on_conflict
}

"""
on conflict condition type for table "event_type"
"""
input event_type_on_conflict {
  constraint: event_type_constraint!
  update_columns: [event_type_update_column!]!
  where: event_type_bool_exp
}

"""
ordering options when selecting data from "event_type"
"""
input event_type_order_by {
  createdAt: order_by
  description: order_by
  duration: order_by
  durationUnit: order_by
  employee: employee_order_by
  employeeId: order_by
  id: order_by
  isActive: order_by
  organizationId: order_by
  tenantId: order_by
  title: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "event_type"
"""
input event_type_pk_columns_input {
  id: uuid!
}

"""
select columns of table "event_type"
"""
enum event_type_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  description

  """
  column name
  """
  duration

  """
  column name
  """
  durationUnit

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  isActive

  """
  column name
  """
  organizationId

  """
  column name
  """
  tenantId

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "event_type"
"""
input event_type_set_input {
  createdAt: timestamp
  description: String
  duration: numeric
  durationUnit: String
  employeeId: uuid
  id: uuid
  isActive: Boolean
  organizationId: uuid
  tenantId: uuid
  title: String
  updatedAt: timestamp
}

"""
aggregate stddev on columns
"""
type event_type_stddev_fields {
  duration: Float
}

"""
order by stddev() on columns of table "event_type"
"""
input event_type_stddev_order_by {
  duration: order_by
}

"""
aggregate stddev_pop on columns
"""
type event_type_stddev_pop_fields {
  duration: Float
}

"""
order by stddev_pop() on columns of table "event_type"
"""
input event_type_stddev_pop_order_by {
  duration: order_by
}

"""
aggregate stddev_samp on columns
"""
type event_type_stddev_samp_fields {
  duration: Float
}

"""
order by stddev_samp() on columns of table "event_type"
"""
input event_type_stddev_samp_order_by {
  duration: order_by
}

"""
aggregate sum on columns
"""
type event_type_sum_fields {
  duration: numeric
}

"""
order by sum() on columns of table "event_type"
"""
input event_type_sum_order_by {
  duration: order_by
}

"""
update columns of table "event_type"
"""
enum event_type_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  description

  """
  column name
  """
  duration

  """
  column name
  """
  durationUnit

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  isActive

  """
  column name
  """
  organizationId

  """
  column name
  """
  tenantId

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt
}

"""
aggregate var_pop on columns
"""
type event_type_var_pop_fields {
  duration: Float
}

"""
order by var_pop() on columns of table "event_type"
"""
input event_type_var_pop_order_by {
  duration: order_by
}

"""
aggregate var_samp on columns
"""
type event_type_var_samp_fields {
  duration: Float
}

"""
order by var_samp() on columns of table "event_type"
"""
input event_type_var_samp_order_by {
  duration: order_by
}

"""
aggregate variance on columns
"""
type event_type_variance_fields {
  duration: Float
}

"""
order by variance() on columns of table "event_type"
"""
input event_type_variance_order_by {
  duration: order_by
}

scalar json

"""
expression to compare columns of type json. All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "activity"
  """
  delete_activity(
    """
    filter the rows which have to be deleted
    """
    where: activity_bool_exp!
  ): activity_mutation_response

  """
  delete single row from the table: "activity"
  """
  delete_activity_by_pk(id: uuid!): activity

  """
  delete data from the table: "appointment_employee"
  """
  delete_appointment_employee(
    """
    filter the rows which have to be deleted
    """
    where: appointment_employee_bool_exp!
  ): appointment_employee_mutation_response

  """
  delete single row from the table: "appointment_employee"
  """
  delete_appointment_employee_by_pk(id: uuid!): appointment_employee

  """
  delete data from the table: "availability_slot"
  """
  delete_availability_slot(
    """
    filter the rows which have to be deleted
    """
    where: availability_slot_bool_exp!
  ): availability_slot_mutation_response

  """
  delete single row from the table: "availability_slot"
  """
  delete_availability_slot_by_pk(id: uuid!): availability_slot

  """
  delete data from the table: "contact"
  """
  delete_contact(
    """
    filter the rows which have to be deleted
    """
    where: contact_bool_exp!
  ): contact_mutation_response

  """
  delete single row from the table: "contact"
  """
  delete_contact_by_pk(id: uuid!): contact

  """
  delete data from the table: "employee"
  """
  delete_employee(
    """
    filter the rows which have to be deleted
    """
    where: employee_bool_exp!
  ): employee_mutation_response

  """
  delete data from the table: "employee_appointment"
  """
  delete_employee_appointment(
    """
    filter the rows which have to be deleted
    """
    where: employee_appointment_bool_exp!
  ): employee_appointment_mutation_response

  """
  delete single row from the table: "employee_appointment"
  """
  delete_employee_appointment_by_pk(id: uuid!): employee_appointment

  """
  delete single row from the table: "employee"
  """
  delete_employee_by_pk(id: uuid!): employee

  """
  delete data from the table: "event_type"
  """
  delete_event_type(
    """
    filter the rows which have to be deleted
    """
    where: event_type_bool_exp!
  ): event_type_mutation_response

  """
  delete single row from the table: "event_type"
  """
  delete_event_type_by_pk(id: uuid!): event_type

  """
  delete data from the table: "role"
  """
  delete_role(
    """
    filter the rows which have to be deleted
    """
    where: role_bool_exp!
  ): role_mutation_response

  """
  delete single row from the table: "role"
  """
  delete_role_by_pk(id: uuid!): role

  """
  delete data from the table: "screenshot"
  """
  delete_screenshot(
    """
    filter the rows which have to be deleted
    """
    where: screenshot_bool_exp!
  ): screenshot_mutation_response

  """
  delete single row from the table: "screenshot"
  """
  delete_screenshot_by_pk(id: uuid!): screenshot

  """
  delete data from the table: "task"
  """
  delete_task(
    """
    filter the rows which have to be deleted
    """
    where: task_bool_exp!
  ): task_mutation_response

  """
  delete single row from the table: "task"
  """
  delete_task_by_pk(id: uuid!): task

  """
  delete data from the table: "time_log"
  """
  delete_time_log(
    """
    filter the rows which have to be deleted
    """
    where: time_log_bool_exp!
  ): time_log_mutation_response

  """
  delete single row from the table: "time_log"
  """
  delete_time_log_by_pk(id: uuid!): time_log

  """
  delete data from the table: "time_slot"
  """
  delete_time_slot(
    """
    filter the rows which have to be deleted
    """
    where: time_slot_bool_exp!
  ): time_slot_mutation_response

  """
  delete single row from the table: "time_slot"
  """
  delete_time_slot_by_pk(id: uuid!): time_slot

  """
  delete data from the table: "time_slot_minute"
  """
  delete_time_slot_minute(
    """
    filter the rows which have to be deleted
    """
    where: time_slot_minute_bool_exp!
  ): time_slot_minute_mutation_response

  """
  delete single row from the table: "time_slot_minute"
  """
  delete_time_slot_minute_by_pk(id: uuid!): time_slot_minute

  """
  delete data from the table: "time_slot_time_logs"
  """
  delete_time_slot_time_logs(
    """
    filter the rows which have to be deleted
    """
    where: time_slot_time_logs_bool_exp!
  ): time_slot_time_logs_mutation_response

  """
  delete single row from the table: "time_slot_time_logs"
  """
  delete_time_slot_time_logs_by_pk(
    timeLogId: uuid!
    timeSlotId: uuid!
  ): time_slot_time_logs

  """
  delete data from the table: "timesheet"
  """
  delete_timesheet(
    """
    filter the rows which have to be deleted
    """
    where: timesheet_bool_exp!
  ): timesheet_mutation_response

  """
  delete single row from the table: "timesheet"
  """
  delete_timesheet_by_pk(id: uuid!): timesheet

  """
  delete data from the table: "user"
  """
  delete_user(
    """
    filter the rows which have to be deleted
    """
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: uuid!): user

  """
  insert data into the table: "activity"
  """
  insert_activity(
    """
    the rows to be inserted
    """
    objects: [activity_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: activity_on_conflict
  ): activity_mutation_response

  """
  insert a single row into the table: "activity"
  """
  insert_activity_one(
    """
    the row to be inserted
    """
    object: activity_insert_input!

    """
    on conflict condition
    """
    on_conflict: activity_on_conflict
  ): activity

  """
  insert data into the table: "appointment_employee"
  """
  insert_appointment_employee(
    """
    the rows to be inserted
    """
    objects: [appointment_employee_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: appointment_employee_on_conflict
  ): appointment_employee_mutation_response

  """
  insert a single row into the table: "appointment_employee"
  """
  insert_appointment_employee_one(
    """
    the row to be inserted
    """
    object: appointment_employee_insert_input!

    """
    on conflict condition
    """
    on_conflict: appointment_employee_on_conflict
  ): appointment_employee

  """
  insert data into the table: "availability_slot"
  """
  insert_availability_slot(
    """
    the rows to be inserted
    """
    objects: [availability_slot_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: availability_slot_on_conflict
  ): availability_slot_mutation_response

  """
  insert a single row into the table: "availability_slot"
  """
  insert_availability_slot_one(
    """
    the row to be inserted
    """
    object: availability_slot_insert_input!

    """
    on conflict condition
    """
    on_conflict: availability_slot_on_conflict
  ): availability_slot

  """
  insert data into the table: "contact"
  """
  insert_contact(
    """
    the rows to be inserted
    """
    objects: [contact_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: contact_on_conflict
  ): contact_mutation_response

  """
  insert a single row into the table: "contact"
  """
  insert_contact_one(
    """
    the row to be inserted
    """
    object: contact_insert_input!

    """
    on conflict condition
    """
    on_conflict: contact_on_conflict
  ): contact

  """
  insert data into the table: "employee"
  """
  insert_employee(
    """
    the rows to be inserted
    """
    objects: [employee_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: employee_on_conflict
  ): employee_mutation_response

  """
  insert data into the table: "employee_appointment"
  """
  insert_employee_appointment(
    """
    the rows to be inserted
    """
    objects: [employee_appointment_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: employee_appointment_on_conflict
  ): employee_appointment_mutation_response

  """
  insert a single row into the table: "employee_appointment"
  """
  insert_employee_appointment_one(
    """
    the row to be inserted
    """
    object: employee_appointment_insert_input!

    """
    on conflict condition
    """
    on_conflict: employee_appointment_on_conflict
  ): employee_appointment

  """
  insert a single row into the table: "employee"
  """
  insert_employee_one(
    """
    the row to be inserted
    """
    object: employee_insert_input!

    """
    on conflict condition
    """
    on_conflict: employee_on_conflict
  ): employee

  """
  insert data into the table: "event_type"
  """
  insert_event_type(
    """
    the rows to be inserted
    """
    objects: [event_type_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: event_type_on_conflict
  ): event_type_mutation_response

  """
  insert a single row into the table: "event_type"
  """
  insert_event_type_one(
    """
    the row to be inserted
    """
    object: event_type_insert_input!

    """
    on conflict condition
    """
    on_conflict: event_type_on_conflict
  ): event_type

  """
  insert data into the table: "role"
  """
  insert_role(
    """
    the rows to be inserted
    """
    objects: [role_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: role_on_conflict
  ): role_mutation_response

  """
  insert a single row into the table: "role"
  """
  insert_role_one(
    """
    the row to be inserted
    """
    object: role_insert_input!

    """
    on conflict condition
    """
    on_conflict: role_on_conflict
  ): role

  """
  insert data into the table: "screenshot"
  """
  insert_screenshot(
    """
    the rows to be inserted
    """
    objects: [screenshot_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: screenshot_on_conflict
  ): screenshot_mutation_response

  """
  insert a single row into the table: "screenshot"
  """
  insert_screenshot_one(
    """
    the row to be inserted
    """
    object: screenshot_insert_input!

    """
    on conflict condition
    """
    on_conflict: screenshot_on_conflict
  ): screenshot

  """
  insert data into the table: "task"
  """
  insert_task(
    """
    the rows to be inserted
    """
    objects: [task_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: task_on_conflict
  ): task_mutation_response

  """
  insert a single row into the table: "task"
  """
  insert_task_one(
    """
    the row to be inserted
    """
    object: task_insert_input!

    """
    on conflict condition
    """
    on_conflict: task_on_conflict
  ): task

  """
  insert data into the table: "time_log"
  """
  insert_time_log(
    """
    the rows to be inserted
    """
    objects: [time_log_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: time_log_on_conflict
  ): time_log_mutation_response

  """
  insert a single row into the table: "time_log"
  """
  insert_time_log_one(
    """
    the row to be inserted
    """
    object: time_log_insert_input!

    """
    on conflict condition
    """
    on_conflict: time_log_on_conflict
  ): time_log

  """
  insert data into the table: "time_slot"
  """
  insert_time_slot(
    """
    the rows to be inserted
    """
    objects: [time_slot_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: time_slot_on_conflict
  ): time_slot_mutation_response

  """
  insert data into the table: "time_slot_minute"
  """
  insert_time_slot_minute(
    """
    the rows to be inserted
    """
    objects: [time_slot_minute_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: time_slot_minute_on_conflict
  ): time_slot_minute_mutation_response

  """
  insert a single row into the table: "time_slot_minute"
  """
  insert_time_slot_minute_one(
    """
    the row to be inserted
    """
    object: time_slot_minute_insert_input!

    """
    on conflict condition
    """
    on_conflict: time_slot_minute_on_conflict
  ): time_slot_minute

  """
  insert a single row into the table: "time_slot"
  """
  insert_time_slot_one(
    """
    the row to be inserted
    """
    object: time_slot_insert_input!

    """
    on conflict condition
    """
    on_conflict: time_slot_on_conflict
  ): time_slot

  """
  insert data into the table: "time_slot_time_logs"
  """
  insert_time_slot_time_logs(
    """
    the rows to be inserted
    """
    objects: [time_slot_time_logs_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: time_slot_time_logs_on_conflict
  ): time_slot_time_logs_mutation_response

  """
  insert a single row into the table: "time_slot_time_logs"
  """
  insert_time_slot_time_logs_one(
    """
    the row to be inserted
    """
    object: time_slot_time_logs_insert_input!

    """
    on conflict condition
    """
    on_conflict: time_slot_time_logs_on_conflict
  ): time_slot_time_logs

  """
  insert data into the table: "timesheet"
  """
  insert_timesheet(
    """
    the rows to be inserted
    """
    objects: [timesheet_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: timesheet_on_conflict
  ): timesheet_mutation_response

  """
  insert a single row into the table: "timesheet"
  """
  insert_timesheet_one(
    """
    the row to be inserted
    """
    object: timesheet_insert_input!

    """
    on conflict condition
    """
    on_conflict: timesheet_on_conflict
  ): timesheet

  """
  insert data into the table: "user"
  """
  insert_user(
    """
    the rows to be inserted
    """
    objects: [user_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """
    the row to be inserted
    """
    object: user_insert_input!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user

  """
  update data of the table: "activity"
  """
  update_activity(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: activity_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: activity_set_input

    """
    filter the rows which have to be updated
    """
    where: activity_bool_exp!
  ): activity_mutation_response

  """
  update single row of the table: "activity"
  """
  update_activity_by_pk(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: activity_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: activity_set_input
    pk_columns: activity_pk_columns_input!
  ): activity

  """
  update data of the table: "appointment_employee"
  """
  update_appointment_employee(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: appointment_employee_set_input

    """
    filter the rows which have to be updated
    """
    where: appointment_employee_bool_exp!
  ): appointment_employee_mutation_response

  """
  update single row of the table: "appointment_employee"
  """
  update_appointment_employee_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: appointment_employee_set_input
    pk_columns: appointment_employee_pk_columns_input!
  ): appointment_employee

  """
  update data of the table: "availability_slot"
  """
  update_availability_slot(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: availability_slot_set_input

    """
    filter the rows which have to be updated
    """
    where: availability_slot_bool_exp!
  ): availability_slot_mutation_response

  """
  update single row of the table: "availability_slot"
  """
  update_availability_slot_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: availability_slot_set_input
    pk_columns: availability_slot_pk_columns_input!
  ): availability_slot

  """
  update data of the table: "contact"
  """
  update_contact(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: contact_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: contact_set_input

    """
    filter the rows which have to be updated
    """
    where: contact_bool_exp!
  ): contact_mutation_response

  """
  update single row of the table: "contact"
  """
  update_contact_by_pk(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: contact_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: contact_set_input
    pk_columns: contact_pk_columns_input!
  ): contact

  """
  update data of the table: "employee"
  """
  update_employee(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: employee_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: employee_set_input

    """
    filter the rows which have to be updated
    """
    where: employee_bool_exp!
  ): employee_mutation_response

  """
  update data of the table: "employee_appointment"
  """
  update_employee_appointment(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: employee_appointment_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: employee_appointment_set_input

    """
    filter the rows which have to be updated
    """
    where: employee_appointment_bool_exp!
  ): employee_appointment_mutation_response

  """
  update single row of the table: "employee_appointment"
  """
  update_employee_appointment_by_pk(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: employee_appointment_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: employee_appointment_set_input
    pk_columns: employee_appointment_pk_columns_input!
  ): employee_appointment

  """
  update single row of the table: "employee"
  """
  update_employee_by_pk(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: employee_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: employee_set_input
    pk_columns: employee_pk_columns_input!
  ): employee

  """
  update data of the table: "event_type"
  """
  update_event_type(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: event_type_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: event_type_set_input

    """
    filter the rows which have to be updated
    """
    where: event_type_bool_exp!
  ): event_type_mutation_response

  """
  update single row of the table: "event_type"
  """
  update_event_type_by_pk(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: event_type_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: event_type_set_input
    pk_columns: event_type_pk_columns_input!
  ): event_type

  """
  update data of the table: "role"
  """
  update_role(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: role_set_input

    """
    filter the rows which have to be updated
    """
    where: role_bool_exp!
  ): role_mutation_response

  """
  update single row of the table: "role"
  """
  update_role_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: role_set_input
    pk_columns: role_pk_columns_input!
  ): role

  """
  update data of the table: "screenshot"
  """
  update_screenshot(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: screenshot_set_input

    """
    filter the rows which have to be updated
    """
    where: screenshot_bool_exp!
  ): screenshot_mutation_response

  """
  update single row of the table: "screenshot"
  """
  update_screenshot_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: screenshot_set_input
    pk_columns: screenshot_pk_columns_input!
  ): screenshot

  """
  update data of the table: "task"
  """
  update_task(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: task_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: task_set_input

    """
    filter the rows which have to be updated
    """
    where: task_bool_exp!
  ): task_mutation_response

  """
  update single row of the table: "task"
  """
  update_task_by_pk(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: task_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: task_set_input
    pk_columns: task_pk_columns_input!
  ): task

  """
  update data of the table: "time_log"
  """
  update_time_log(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: time_log_set_input

    """
    filter the rows which have to be updated
    """
    where: time_log_bool_exp!
  ): time_log_mutation_response

  """
  update single row of the table: "time_log"
  """
  update_time_log_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: time_log_set_input
    pk_columns: time_log_pk_columns_input!
  ): time_log

  """
  update data of the table: "time_slot"
  """
  update_time_slot(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: time_slot_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: time_slot_set_input

    """
    filter the rows which have to be updated
    """
    where: time_slot_bool_exp!
  ): time_slot_mutation_response

  """
  update single row of the table: "time_slot"
  """
  update_time_slot_by_pk(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: time_slot_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: time_slot_set_input
    pk_columns: time_slot_pk_columns_input!
  ): time_slot

  """
  update data of the table: "time_slot_minute"
  """
  update_time_slot_minute(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: time_slot_minute_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: time_slot_minute_set_input

    """
    filter the rows which have to be updated
    """
    where: time_slot_minute_bool_exp!
  ): time_slot_minute_mutation_response

  """
  update single row of the table: "time_slot_minute"
  """
  update_time_slot_minute_by_pk(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: time_slot_minute_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: time_slot_minute_set_input
    pk_columns: time_slot_minute_pk_columns_input!
  ): time_slot_minute

  """
  update data of the table: "time_slot_time_logs"
  """
  update_time_slot_time_logs(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: time_slot_time_logs_set_input

    """
    filter the rows which have to be updated
    """
    where: time_slot_time_logs_bool_exp!
  ): time_slot_time_logs_mutation_response

  """
  update single row of the table: "time_slot_time_logs"
  """
  update_time_slot_time_logs_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: time_slot_time_logs_set_input
    pk_columns: time_slot_time_logs_pk_columns_input!
  ): time_slot_time_logs

  """
  update data of the table: "timesheet"
  """
  update_timesheet(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: timesheet_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: timesheet_set_input

    """
    filter the rows which have to be updated
    """
    where: timesheet_bool_exp!
  ): timesheet_mutation_response

  """
  update single row of the table: "timesheet"
  """
  update_timesheet_by_pk(
    """
    increments the integer columns with given value of the filtered values
    """
    _inc: timesheet_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: timesheet_set_input
    pk_columns: timesheet_pk_columns_input!
  ): timesheet

  """
  update data of the table: "user"
  """
  update_user(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input

    """
    filter the rows which have to be updated
    """
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user
}

scalar numeric

"""
expression to compare columns of type numeric. All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
  """
  in the ascending order, nulls last
  """
  asc

  """
  in the ascending order, nulls first
  """
  asc_nulls_first

  """
  in the ascending order, nulls last
  """
  asc_nulls_last

  """
  in the descending order, nulls first
  """
  desc

  """
  in the descending order, nulls first
  """
  desc_nulls_first

  """
  in the descending order, nulls last
  """
  desc_nulls_last
}

"""
query root
"""
type query_root {
  """
  fetch data from the table: "activity"
  """
  activity(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): [activity!]!

  """
  fetch aggregated fields from the table: "activity"
  """
  activity_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): activity_aggregate!

  """
  fetch data from the table: "activity" using primary key columns
  """
  activity_by_pk(id: uuid!): activity

  """
  fetch data from the table: "appointment_employee"
  """
  appointment_employee(
    """
    distinct select on columns
    """
    distinct_on: [appointment_employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [appointment_employee_order_by!]

    """
    filter the rows returned
    """
    where: appointment_employee_bool_exp
  ): [appointment_employee!]!

  """
  fetch aggregated fields from the table: "appointment_employee"
  """
  appointment_employee_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [appointment_employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [appointment_employee_order_by!]

    """
    filter the rows returned
    """
    where: appointment_employee_bool_exp
  ): appointment_employee_aggregate!

  """
  fetch data from the table: "appointment_employee" using primary key columns
  """
  appointment_employee_by_pk(id: uuid!): appointment_employee

  """
  fetch data from the table: "availability_slot"
  """
  availability_slot(
    """
    distinct select on columns
    """
    distinct_on: [availability_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [availability_slot_order_by!]

    """
    filter the rows returned
    """
    where: availability_slot_bool_exp
  ): [availability_slot!]!

  """
  fetch aggregated fields from the table: "availability_slot"
  """
  availability_slot_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [availability_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [availability_slot_order_by!]

    """
    filter the rows returned
    """
    where: availability_slot_bool_exp
  ): availability_slot_aggregate!

  """
  fetch data from the table: "availability_slot" using primary key columns
  """
  availability_slot_by_pk(id: uuid!): availability_slot

  """
  fetch data from the table: "contact"
  """
  contact(
    """
    distinct select on columns
    """
    distinct_on: [contact_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [contact_order_by!]

    """
    filter the rows returned
    """
    where: contact_bool_exp
  ): [contact!]!

  """
  fetch aggregated fields from the table: "contact"
  """
  contact_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [contact_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [contact_order_by!]

    """
    filter the rows returned
    """
    where: contact_bool_exp
  ): contact_aggregate!

  """
  fetch data from the table: "contact" using primary key columns
  """
  contact_by_pk(id: uuid!): contact

  """
  fetch data from the table: "employee"
  """
  employee(
    """
    distinct select on columns
    """
    distinct_on: [employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_order_by!]

    """
    filter the rows returned
    """
    where: employee_bool_exp
  ): [employee!]!

  """
  fetch aggregated fields from the table: "employee"
  """
  employee_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_order_by!]

    """
    filter the rows returned
    """
    where: employee_bool_exp
  ): employee_aggregate!

  """
  fetch data from the table: "employee_appointment"
  """
  employee_appointment(
    """
    distinct select on columns
    """
    distinct_on: [employee_appointment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_appointment_order_by!]

    """
    filter the rows returned
    """
    where: employee_appointment_bool_exp
  ): [employee_appointment!]!

  """
  fetch aggregated fields from the table: "employee_appointment"
  """
  employee_appointment_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [employee_appointment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_appointment_order_by!]

    """
    filter the rows returned
    """
    where: employee_appointment_bool_exp
  ): employee_appointment_aggregate!

  """
  fetch data from the table: "employee_appointment" using primary key columns
  """
  employee_appointment_by_pk(id: uuid!): employee_appointment

  """
  fetch data from the table: "employee" using primary key columns
  """
  employee_by_pk(id: uuid!): employee

  """
  fetch data from the table: "event_type"
  """
  event_type(
    """
    distinct select on columns
    """
    distinct_on: [event_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [event_type_order_by!]

    """
    filter the rows returned
    """
    where: event_type_bool_exp
  ): [event_type!]!

  """
  fetch aggregated fields from the table: "event_type"
  """
  event_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [event_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [event_type_order_by!]

    """
    filter the rows returned
    """
    where: event_type_bool_exp
  ): event_type_aggregate!

  """
  fetch data from the table: "event_type" using primary key columns
  """
  event_type_by_pk(id: uuid!): event_type

  """
  fetch data from the table: "role"
  """
  role(
    """
    distinct select on columns
    """
    distinct_on: [role_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [role_order_by!]

    """
    filter the rows returned
    """
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [role_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [role_order_by!]

    """
    filter the rows returned
    """
    where: role_bool_exp
  ): role_aggregate!

  """
  fetch data from the table: "role" using primary key columns
  """
  role_by_pk(id: uuid!): role

  """
  fetch data from the table: "screenshot"
  """
  screenshot(
    """
    distinct select on columns
    """
    distinct_on: [screenshot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [screenshot_order_by!]

    """
    filter the rows returned
    """
    where: screenshot_bool_exp
  ): [screenshot!]!

  """
  fetch aggregated fields from the table: "screenshot"
  """
  screenshot_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [screenshot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [screenshot_order_by!]

    """
    filter the rows returned
    """
    where: screenshot_bool_exp
  ): screenshot_aggregate!

  """
  fetch data from the table: "screenshot" using primary key columns
  """
  screenshot_by_pk(id: uuid!): screenshot

  """
  fetch data from the table: "task"
  """
  task(
    """
    distinct select on columns
    """
    distinct_on: [task_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [task_order_by!]

    """
    filter the rows returned
    """
    where: task_bool_exp
  ): [task!]!

  """
  fetch aggregated fields from the table: "task"
  """
  task_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [task_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [task_order_by!]

    """
    filter the rows returned
    """
    where: task_bool_exp
  ): task_aggregate!

  """
  fetch data from the table: "task" using primary key columns
  """
  task_by_pk(id: uuid!): task

  """
  fetch data from the table: "time_log"
  """
  time_log(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): [time_log!]!

  """
  fetch aggregated fields from the table: "time_log"
  """
  time_log_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): time_log_aggregate!

  """
  fetch data from the table: "time_log" using primary key columns
  """
  time_log_by_pk(id: uuid!): time_log

  """
  fetch data from the table: "time_slot"
  """
  time_slot(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_bool_exp
  ): [time_slot!]!

  """
  fetch aggregated fields from the table: "time_slot"
  """
  time_slot_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_bool_exp
  ): time_slot_aggregate!

  """
  fetch data from the table: "time_slot" using primary key columns
  """
  time_slot_by_pk(id: uuid!): time_slot

  """
  fetch data from the table: "time_slot_minute"
  """
  time_slot_minute(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_minute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_minute_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_minute_bool_exp
  ): [time_slot_minute!]!

  """
  fetch aggregated fields from the table: "time_slot_minute"
  """
  time_slot_minute_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_minute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_minute_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_minute_bool_exp
  ): time_slot_minute_aggregate!

  """
  fetch data from the table: "time_slot_minute" using primary key columns
  """
  time_slot_minute_by_pk(id: uuid!): time_slot_minute

  """
  fetch data from the table: "time_slot_time_logs"
  """
  time_slot_time_logs(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_time_logs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_time_logs_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_time_logs_bool_exp
  ): [time_slot_time_logs!]!

  """
  fetch aggregated fields from the table: "time_slot_time_logs"
  """
  time_slot_time_logs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_time_logs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_time_logs_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_time_logs_bool_exp
  ): time_slot_time_logs_aggregate!

  """
  fetch data from the table: "time_slot_time_logs" using primary key columns
  """
  time_slot_time_logs_by_pk(
    timeLogId: uuid!
    timeSlotId: uuid!
  ): time_slot_time_logs

  """
  fetch data from the table: "timesheet"
  """
  timesheet(
    """
    distinct select on columns
    """
    distinct_on: [timesheet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timesheet_order_by!]

    """
    filter the rows returned
    """
    where: timesheet_bool_exp
  ): [timesheet!]!

  """
  fetch aggregated fields from the table: "timesheet"
  """
  timesheet_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timesheet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timesheet_order_by!]

    """
    filter the rows returned
    """
    where: timesheet_bool_exp
  ): timesheet_aggregate!

  """
  fetch data from the table: "timesheet" using primary key columns
  """
  timesheet_by_pk(id: uuid!): timesheet

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  user_by_pk(id: uuid!): user
}

"""
columns and relationships of "role"
"""
type role {
  createdAt: timestamp!
  id: uuid!
  name: String!
  tenantId: uuid
  updatedAt: timestamp!

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  An aggregated array relationship
  """
  users_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!
}

"""
aggregated selection of "role"
"""
type role_aggregate {
  aggregate: role_aggregate_fields
  nodes: [role!]!
}

"""
aggregate fields of "role"
"""
type role_aggregate_fields {
  count(columns: [role_select_column!], distinct: Boolean): Int
  max: role_max_fields
  min: role_min_fields
}

"""
order by aggregate values of table "role"
"""
input role_aggregate_order_by {
  count: order_by
  max: role_max_order_by
  min: role_min_order_by
}

"""
input type for inserting array relation for remote table "role"
"""
input role_arr_rel_insert_input {
  data: [role_insert_input!]!
  on_conflict: role_on_conflict
}

"""
Boolean expression to filter rows from the table "role". All fields are combined with a logical 'AND'.
"""
input role_bool_exp {
  _and: [role_bool_exp]
  _not: role_bool_exp
  _or: [role_bool_exp]
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  tenantId: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
  users: user_bool_exp
}

"""
unique or primary key constraints on table "role"
"""
enum role_constraint {
  """
  unique or primary key constraint
  """
  PK_b36bcfe02fc8de3c57a8b2391c2
}

"""
input type for inserting data into table "role"
"""
input role_insert_input {
  createdAt: timestamp
  id: uuid
  name: String
  tenantId: uuid
  updatedAt: timestamp
  users: user_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type role_max_fields {
  createdAt: timestamp
  id: uuid
  name: String
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by max() on columns of table "role"
"""
input role_max_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type role_min_fields {
  createdAt: timestamp
  id: uuid
  name: String
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by min() on columns of table "role"
"""
input role_min_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "role"
"""
type role_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [role!]!
}

"""
input type for inserting object relation for remote table "role"
"""
input role_obj_rel_insert_input {
  data: role_insert_input!
  on_conflict: role_on_conflict
}

"""
on conflict condition type for table "role"
"""
input role_on_conflict {
  constraint: role_constraint!
  update_columns: [role_update_column!]!
  where: role_bool_exp
}

"""
ordering options when selecting data from "role"
"""
input role_order_by {
  createdAt: order_by
  id: order_by
  name: order_by
  tenantId: order_by
  updatedAt: order_by
  users_aggregate: user_aggregate_order_by
}

"""
primary key columns input for table: "role"
"""
input role_pk_columns_input {
  id: uuid!
}

"""
select columns of table "role"
"""
enum role_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "role"
"""
input role_set_input {
  createdAt: timestamp
  id: uuid
  name: String
  tenantId: uuid
  updatedAt: timestamp
}

"""
update columns of table "role"
"""
enum role_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
columns and relationships of "screenshot"
"""
type screenshot {
  createdAt: timestamp!
  deletedAt: timestamp
  file: String!
  id: uuid!
  organizationId: uuid
  recordedAt: timestamp
  tenantId: uuid
  thumb: String
  timeSlotId: uuid

  """
  An object relationship
  """
  time_slot: time_slot
  updatedAt: timestamp!
}

"""
aggregated selection of "screenshot"
"""
type screenshot_aggregate {
  aggregate: screenshot_aggregate_fields
  nodes: [screenshot!]!
}

"""
aggregate fields of "screenshot"
"""
type screenshot_aggregate_fields {
  count(columns: [screenshot_select_column!], distinct: Boolean): Int
  max: screenshot_max_fields
  min: screenshot_min_fields
}

"""
order by aggregate values of table "screenshot"
"""
input screenshot_aggregate_order_by {
  count: order_by
  max: screenshot_max_order_by
  min: screenshot_min_order_by
}

"""
input type for inserting array relation for remote table "screenshot"
"""
input screenshot_arr_rel_insert_input {
  data: [screenshot_insert_input!]!
  on_conflict: screenshot_on_conflict
}

"""
Boolean expression to filter rows from the table "screenshot". All fields are combined with a logical 'AND'.
"""
input screenshot_bool_exp {
  _and: [screenshot_bool_exp]
  _not: screenshot_bool_exp
  _or: [screenshot_bool_exp]
  createdAt: timestamp_comparison_exp
  deletedAt: timestamp_comparison_exp
  file: String_comparison_exp
  id: uuid_comparison_exp
  organizationId: uuid_comparison_exp
  recordedAt: timestamp_comparison_exp
  tenantId: uuid_comparison_exp
  thumb: String_comparison_exp
  timeSlotId: uuid_comparison_exp
  time_slot: time_slot_bool_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "screenshot"
"""
enum screenshot_constraint {
  """
  unique or primary key constraint
  """
  PK_ba03e6a8a41f430189837f84fd9
}

"""
input type for inserting data into table "screenshot"
"""
input screenshot_insert_input {
  createdAt: timestamp
  deletedAt: timestamp
  file: String
  id: uuid
  organizationId: uuid
  recordedAt: timestamp
  tenantId: uuid
  thumb: String
  timeSlotId: uuid
  time_slot: time_slot_obj_rel_insert_input
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type screenshot_max_fields {
  createdAt: timestamp
  deletedAt: timestamp
  file: String
  id: uuid
  organizationId: uuid
  recordedAt: timestamp
  tenantId: uuid
  thumb: String
  timeSlotId: uuid
  updatedAt: timestamp
}

"""
order by max() on columns of table "screenshot"
"""
input screenshot_max_order_by {
  createdAt: order_by
  deletedAt: order_by
  file: order_by
  id: order_by
  organizationId: order_by
  recordedAt: order_by
  tenantId: order_by
  thumb: order_by
  timeSlotId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type screenshot_min_fields {
  createdAt: timestamp
  deletedAt: timestamp
  file: String
  id: uuid
  organizationId: uuid
  recordedAt: timestamp
  tenantId: uuid
  thumb: String
  timeSlotId: uuid
  updatedAt: timestamp
}

"""
order by min() on columns of table "screenshot"
"""
input screenshot_min_order_by {
  createdAt: order_by
  deletedAt: order_by
  file: order_by
  id: order_by
  organizationId: order_by
  recordedAt: order_by
  tenantId: order_by
  thumb: order_by
  timeSlotId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "screenshot"
"""
type screenshot_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [screenshot!]!
}

"""
input type for inserting object relation for remote table "screenshot"
"""
input screenshot_obj_rel_insert_input {
  data: screenshot_insert_input!
  on_conflict: screenshot_on_conflict
}

"""
on conflict condition type for table "screenshot"
"""
input screenshot_on_conflict {
  constraint: screenshot_constraint!
  update_columns: [screenshot_update_column!]!
  where: screenshot_bool_exp
}

"""
ordering options when selecting data from "screenshot"
"""
input screenshot_order_by {
  createdAt: order_by
  deletedAt: order_by
  file: order_by
  id: order_by
  organizationId: order_by
  recordedAt: order_by
  tenantId: order_by
  thumb: order_by
  timeSlotId: order_by
  time_slot: time_slot_order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "screenshot"
"""
input screenshot_pk_columns_input {
  id: uuid!
}

"""
select columns of table "screenshot"
"""
enum screenshot_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  deletedAt

  """
  column name
  """
  file

  """
  column name
  """
  id

  """
  column name
  """
  organizationId

  """
  column name
  """
  recordedAt

  """
  column name
  """
  tenantId

  """
  column name
  """
  thumb

  """
  column name
  """
  timeSlotId

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "screenshot"
"""
input screenshot_set_input {
  createdAt: timestamp
  deletedAt: timestamp
  file: String
  id: uuid
  organizationId: uuid
  recordedAt: timestamp
  tenantId: uuid
  thumb: String
  timeSlotId: uuid
  updatedAt: timestamp
}

"""
update columns of table "screenshot"
"""
enum screenshot_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  deletedAt

  """
  column name
  """
  file

  """
  column name
  """
  id

  """
  column name
  """
  organizationId

  """
  column name
  """
  recordedAt

  """
  column name
  """
  tenantId

  """
  column name
  """
  thumb

  """
  column name
  """
  timeSlotId

  """
  column name
  """
  updatedAt
}

"""
subscription root
"""
type subscription_root {
  """
  fetch data from the table: "activity"
  """
  activity(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): [activity!]!

  """
  fetch aggregated fields from the table: "activity"
  """
  activity_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): activity_aggregate!

  """
  fetch data from the table: "activity" using primary key columns
  """
  activity_by_pk(id: uuid!): activity

  """
  fetch data from the table: "appointment_employee"
  """
  appointment_employee(
    """
    distinct select on columns
    """
    distinct_on: [appointment_employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [appointment_employee_order_by!]

    """
    filter the rows returned
    """
    where: appointment_employee_bool_exp
  ): [appointment_employee!]!

  """
  fetch aggregated fields from the table: "appointment_employee"
  """
  appointment_employee_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [appointment_employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [appointment_employee_order_by!]

    """
    filter the rows returned
    """
    where: appointment_employee_bool_exp
  ): appointment_employee_aggregate!

  """
  fetch data from the table: "appointment_employee" using primary key columns
  """
  appointment_employee_by_pk(id: uuid!): appointment_employee

  """
  fetch data from the table: "availability_slot"
  """
  availability_slot(
    """
    distinct select on columns
    """
    distinct_on: [availability_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [availability_slot_order_by!]

    """
    filter the rows returned
    """
    where: availability_slot_bool_exp
  ): [availability_slot!]!

  """
  fetch aggregated fields from the table: "availability_slot"
  """
  availability_slot_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [availability_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [availability_slot_order_by!]

    """
    filter the rows returned
    """
    where: availability_slot_bool_exp
  ): availability_slot_aggregate!

  """
  fetch data from the table: "availability_slot" using primary key columns
  """
  availability_slot_by_pk(id: uuid!): availability_slot

  """
  fetch data from the table: "contact"
  """
  contact(
    """
    distinct select on columns
    """
    distinct_on: [contact_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [contact_order_by!]

    """
    filter the rows returned
    """
    where: contact_bool_exp
  ): [contact!]!

  """
  fetch aggregated fields from the table: "contact"
  """
  contact_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [contact_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [contact_order_by!]

    """
    filter the rows returned
    """
    where: contact_bool_exp
  ): contact_aggregate!

  """
  fetch data from the table: "contact" using primary key columns
  """
  contact_by_pk(id: uuid!): contact

  """
  fetch data from the table: "employee"
  """
  employee(
    """
    distinct select on columns
    """
    distinct_on: [employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_order_by!]

    """
    filter the rows returned
    """
    where: employee_bool_exp
  ): [employee!]!

  """
  fetch aggregated fields from the table: "employee"
  """
  employee_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [employee_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_order_by!]

    """
    filter the rows returned
    """
    where: employee_bool_exp
  ): employee_aggregate!

  """
  fetch data from the table: "employee_appointment"
  """
  employee_appointment(
    """
    distinct select on columns
    """
    distinct_on: [employee_appointment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_appointment_order_by!]

    """
    filter the rows returned
    """
    where: employee_appointment_bool_exp
  ): [employee_appointment!]!

  """
  fetch aggregated fields from the table: "employee_appointment"
  """
  employee_appointment_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [employee_appointment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [employee_appointment_order_by!]

    """
    filter the rows returned
    """
    where: employee_appointment_bool_exp
  ): employee_appointment_aggregate!

  """
  fetch data from the table: "employee_appointment" using primary key columns
  """
  employee_appointment_by_pk(id: uuid!): employee_appointment

  """
  fetch data from the table: "employee" using primary key columns
  """
  employee_by_pk(id: uuid!): employee

  """
  fetch data from the table: "event_type"
  """
  event_type(
    """
    distinct select on columns
    """
    distinct_on: [event_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [event_type_order_by!]

    """
    filter the rows returned
    """
    where: event_type_bool_exp
  ): [event_type!]!

  """
  fetch aggregated fields from the table: "event_type"
  """
  event_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [event_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [event_type_order_by!]

    """
    filter the rows returned
    """
    where: event_type_bool_exp
  ): event_type_aggregate!

  """
  fetch data from the table: "event_type" using primary key columns
  """
  event_type_by_pk(id: uuid!): event_type

  """
  fetch data from the table: "role"
  """
  role(
    """
    distinct select on columns
    """
    distinct_on: [role_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [role_order_by!]

    """
    filter the rows returned
    """
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [role_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [role_order_by!]

    """
    filter the rows returned
    """
    where: role_bool_exp
  ): role_aggregate!

  """
  fetch data from the table: "role" using primary key columns
  """
  role_by_pk(id: uuid!): role

  """
  fetch data from the table: "screenshot"
  """
  screenshot(
    """
    distinct select on columns
    """
    distinct_on: [screenshot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [screenshot_order_by!]

    """
    filter the rows returned
    """
    where: screenshot_bool_exp
  ): [screenshot!]!

  """
  fetch aggregated fields from the table: "screenshot"
  """
  screenshot_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [screenshot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [screenshot_order_by!]

    """
    filter the rows returned
    """
    where: screenshot_bool_exp
  ): screenshot_aggregate!

  """
  fetch data from the table: "screenshot" using primary key columns
  """
  screenshot_by_pk(id: uuid!): screenshot

  """
  fetch data from the table: "task"
  """
  task(
    """
    distinct select on columns
    """
    distinct_on: [task_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [task_order_by!]

    """
    filter the rows returned
    """
    where: task_bool_exp
  ): [task!]!

  """
  fetch aggregated fields from the table: "task"
  """
  task_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [task_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [task_order_by!]

    """
    filter the rows returned
    """
    where: task_bool_exp
  ): task_aggregate!

  """
  fetch data from the table: "task" using primary key columns
  """
  task_by_pk(id: uuid!): task

  """
  fetch data from the table: "time_log"
  """
  time_log(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): [time_log!]!

  """
  fetch aggregated fields from the table: "time_log"
  """
  time_log_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): time_log_aggregate!

  """
  fetch data from the table: "time_log" using primary key columns
  """
  time_log_by_pk(id: uuid!): time_log

  """
  fetch data from the table: "time_slot"
  """
  time_slot(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_bool_exp
  ): [time_slot!]!

  """
  fetch aggregated fields from the table: "time_slot"
  """
  time_slot_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_bool_exp
  ): time_slot_aggregate!

  """
  fetch data from the table: "time_slot" using primary key columns
  """
  time_slot_by_pk(id: uuid!): time_slot

  """
  fetch data from the table: "time_slot_minute"
  """
  time_slot_minute(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_minute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_minute_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_minute_bool_exp
  ): [time_slot_minute!]!

  """
  fetch aggregated fields from the table: "time_slot_minute"
  """
  time_slot_minute_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_minute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_minute_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_minute_bool_exp
  ): time_slot_minute_aggregate!

  """
  fetch data from the table: "time_slot_minute" using primary key columns
  """
  time_slot_minute_by_pk(id: uuid!): time_slot_minute

  """
  fetch data from the table: "time_slot_time_logs"
  """
  time_slot_time_logs(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_time_logs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_time_logs_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_time_logs_bool_exp
  ): [time_slot_time_logs!]!

  """
  fetch aggregated fields from the table: "time_slot_time_logs"
  """
  time_slot_time_logs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_time_logs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_time_logs_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_time_logs_bool_exp
  ): time_slot_time_logs_aggregate!

  """
  fetch data from the table: "time_slot_time_logs" using primary key columns
  """
  time_slot_time_logs_by_pk(
    timeLogId: uuid!
    timeSlotId: uuid!
  ): time_slot_time_logs

  """
  fetch data from the table: "timesheet"
  """
  timesheet(
    """
    distinct select on columns
    """
    distinct_on: [timesheet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timesheet_order_by!]

    """
    filter the rows returned
    """
    where: timesheet_bool_exp
  ): [timesheet!]!

  """
  fetch aggregated fields from the table: "timesheet"
  """
  timesheet_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timesheet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timesheet_order_by!]

    """
    filter the rows returned
    """
    where: timesheet_bool_exp
  ): timesheet_aggregate!

  """
  fetch data from the table: "timesheet" using primary key columns
  """
  timesheet_by_pk(id: uuid!): timesheet

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  user_by_pk(id: uuid!): user
}

"""
columns and relationships of "task"
"""
type task {
  """
  An array relationship
  """
  activities(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): [activity!]!

  """
  An aggregated array relationship
  """
  activities_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): activity_aggregate!
  createdAt: timestamp!
  creatorId: uuid!
  description: String
  dueDate: timestamp
  estimate: Int
  id: uuid!
  organizationId: uuid
  organizationSprintId: uuid
  projectId: uuid
  status: String!
  tenantId: uuid

  """
  An array relationship
  """
  time_logs(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): [time_log!]!

  """
  An aggregated array relationship
  """
  time_logs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): time_log_aggregate!
  title: String!
  updatedAt: timestamp!

  """
  An object relationship
  """
  user: user!
}

"""
aggregated selection of "task"
"""
type task_aggregate {
  aggregate: task_aggregate_fields
  nodes: [task!]!
}

"""
aggregate fields of "task"
"""
type task_aggregate_fields {
  avg: task_avg_fields
  count(columns: [task_select_column!], distinct: Boolean): Int
  max: task_max_fields
  min: task_min_fields
  stddev: task_stddev_fields
  stddev_pop: task_stddev_pop_fields
  stddev_samp: task_stddev_samp_fields
  sum: task_sum_fields
  var_pop: task_var_pop_fields
  var_samp: task_var_samp_fields
  variance: task_variance_fields
}

"""
order by aggregate values of table "task"
"""
input task_aggregate_order_by {
  avg: task_avg_order_by
  count: order_by
  max: task_max_order_by
  min: task_min_order_by
  stddev: task_stddev_order_by
  stddev_pop: task_stddev_pop_order_by
  stddev_samp: task_stddev_samp_order_by
  sum: task_sum_order_by
  var_pop: task_var_pop_order_by
  var_samp: task_var_samp_order_by
  variance: task_variance_order_by
}

"""
input type for inserting array relation for remote table "task"
"""
input task_arr_rel_insert_input {
  data: [task_insert_input!]!
  on_conflict: task_on_conflict
}

"""
aggregate avg on columns
"""
type task_avg_fields {
  estimate: Float
}

"""
order by avg() on columns of table "task"
"""
input task_avg_order_by {
  estimate: order_by
}

"""
Boolean expression to filter rows from the table "task". All fields are combined with a logical 'AND'.
"""
input task_bool_exp {
  _and: [task_bool_exp]
  _not: task_bool_exp
  _or: [task_bool_exp]
  activities: activity_bool_exp
  createdAt: timestamp_comparison_exp
  creatorId: uuid_comparison_exp
  description: String_comparison_exp
  dueDate: timestamp_comparison_exp
  estimate: Int_comparison_exp
  id: uuid_comparison_exp
  organizationId: uuid_comparison_exp
  organizationSprintId: uuid_comparison_exp
  projectId: uuid_comparison_exp
  status: String_comparison_exp
  tenantId: uuid_comparison_exp
  time_logs: time_log_bool_exp
  title: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "task"
"""
enum task_constraint {
  """
  unique or primary key constraint
  """
  PK_fb213f79ee45060ba925ecd576e
}

"""
input type for incrementing integer column in table "task"
"""
input task_inc_input {
  estimate: Int
}

"""
input type for inserting data into table "task"
"""
input task_insert_input {
  activities: activity_arr_rel_insert_input
  createdAt: timestamp
  creatorId: uuid
  description: String
  dueDate: timestamp
  estimate: Int
  id: uuid
  organizationId: uuid
  organizationSprintId: uuid
  projectId: uuid
  status: String
  tenantId: uuid
  time_logs: time_log_arr_rel_insert_input
  title: String
  updatedAt: timestamp
  user: user_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type task_max_fields {
  createdAt: timestamp
  creatorId: uuid
  description: String
  dueDate: timestamp
  estimate: Int
  id: uuid
  organizationId: uuid
  organizationSprintId: uuid
  projectId: uuid
  status: String
  tenantId: uuid
  title: String
  updatedAt: timestamp
}

"""
order by max() on columns of table "task"
"""
input task_max_order_by {
  createdAt: order_by
  creatorId: order_by
  description: order_by
  dueDate: order_by
  estimate: order_by
  id: order_by
  organizationId: order_by
  organizationSprintId: order_by
  projectId: order_by
  status: order_by
  tenantId: order_by
  title: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type task_min_fields {
  createdAt: timestamp
  creatorId: uuid
  description: String
  dueDate: timestamp
  estimate: Int
  id: uuid
  organizationId: uuid
  organizationSprintId: uuid
  projectId: uuid
  status: String
  tenantId: uuid
  title: String
  updatedAt: timestamp
}

"""
order by min() on columns of table "task"
"""
input task_min_order_by {
  createdAt: order_by
  creatorId: order_by
  description: order_by
  dueDate: order_by
  estimate: order_by
  id: order_by
  organizationId: order_by
  organizationSprintId: order_by
  projectId: order_by
  status: order_by
  tenantId: order_by
  title: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "task"
"""
type task_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [task!]!
}

"""
input type for inserting object relation for remote table "task"
"""
input task_obj_rel_insert_input {
  data: task_insert_input!
  on_conflict: task_on_conflict
}

"""
on conflict condition type for table "task"
"""
input task_on_conflict {
  constraint: task_constraint!
  update_columns: [task_update_column!]!
  where: task_bool_exp
}

"""
ordering options when selecting data from "task"
"""
input task_order_by {
  activities_aggregate: activity_aggregate_order_by
  createdAt: order_by
  creatorId: order_by
  description: order_by
  dueDate: order_by
  estimate: order_by
  id: order_by
  organizationId: order_by
  organizationSprintId: order_by
  projectId: order_by
  status: order_by
  tenantId: order_by
  time_logs_aggregate: time_log_aggregate_order_by
  title: order_by
  updatedAt: order_by
  user: user_order_by
}

"""
primary key columns input for table: "task"
"""
input task_pk_columns_input {
  id: uuid!
}

"""
select columns of table "task"
"""
enum task_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  creatorId

  """
  column name
  """
  description

  """
  column name
  """
  dueDate

  """
  column name
  """
  estimate

  """
  column name
  """
  id

  """
  column name
  """
  organizationId

  """
  column name
  """
  organizationSprintId

  """
  column name
  """
  projectId

  """
  column name
  """
  status

  """
  column name
  """
  tenantId

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "task"
"""
input task_set_input {
  createdAt: timestamp
  creatorId: uuid
  description: String
  dueDate: timestamp
  estimate: Int
  id: uuid
  organizationId: uuid
  organizationSprintId: uuid
  projectId: uuid
  status: String
  tenantId: uuid
  title: String
  updatedAt: timestamp
}

"""
aggregate stddev on columns
"""
type task_stddev_fields {
  estimate: Float
}

"""
order by stddev() on columns of table "task"
"""
input task_stddev_order_by {
  estimate: order_by
}

"""
aggregate stddev_pop on columns
"""
type task_stddev_pop_fields {
  estimate: Float
}

"""
order by stddev_pop() on columns of table "task"
"""
input task_stddev_pop_order_by {
  estimate: order_by
}

"""
aggregate stddev_samp on columns
"""
type task_stddev_samp_fields {
  estimate: Float
}

"""
order by stddev_samp() on columns of table "task"
"""
input task_stddev_samp_order_by {
  estimate: order_by
}

"""
aggregate sum on columns
"""
type task_sum_fields {
  estimate: Int
}

"""
order by sum() on columns of table "task"
"""
input task_sum_order_by {
  estimate: order_by
}

"""
update columns of table "task"
"""
enum task_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  creatorId

  """
  column name
  """
  description

  """
  column name
  """
  dueDate

  """
  column name
  """
  estimate

  """
  column name
  """
  id

  """
  column name
  """
  organizationId

  """
  column name
  """
  organizationSprintId

  """
  column name
  """
  projectId

  """
  column name
  """
  status

  """
  column name
  """
  tenantId

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt
}

"""
aggregate var_pop on columns
"""
type task_var_pop_fields {
  estimate: Float
}

"""
order by var_pop() on columns of table "task"
"""
input task_var_pop_order_by {
  estimate: order_by
}

"""
aggregate var_samp on columns
"""
type task_var_samp_fields {
  estimate: Float
}

"""
order by var_samp() on columns of table "task"
"""
input task_var_samp_order_by {
  estimate: order_by
}

"""
aggregate variance on columns
"""
type task_variance_fields {
  estimate: Float
}

"""
order by variance() on columns of table "task"
"""
input task_variance_order_by {
  estimate: order_by
}

scalar time

"""
expression to compare columns of type time. All fields are combined with logical 'AND'.
"""
input time_comparison_exp {
  _eq: time
  _gt: time
  _gte: time
  _in: [time!]
  _is_null: Boolean
  _lt: time
  _lte: time
  _neq: time
  _nin: [time!]
}

"""
columns and relationships of "time_log"
"""
type time_log {
  createdAt: timestamp!
  deletedAt: timestamp
  description: String

  """
  An object relationship
  """
  employee: employee!
  employeeId: uuid!
  id: uuid!
  isBillable: Boolean!
  logType: String!
  organizationContactId: uuid
  organizationId: uuid
  projectId: uuid
  reason: String
  source: String!
  startedAt: timestamp
  stoppedAt: timestamp

  """
  An object relationship
  """
  task: task
  taskId: uuid
  tenantId: uuid

  """
  An array relationship
  """
  time_slot_time_logs(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_time_logs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_time_logs_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_time_logs_bool_exp
  ): [time_slot_time_logs!]!

  """
  An aggregated array relationship
  """
  time_slot_time_logs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_time_logs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_time_logs_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_time_logs_bool_exp
  ): time_slot_time_logs_aggregate!

  """
  An object relationship
  """
  timesheet: timesheet
  timesheetId: uuid
  updatedAt: timestamp!
}

"""
aggregated selection of "time_log"
"""
type time_log_aggregate {
  aggregate: time_log_aggregate_fields
  nodes: [time_log!]!
}

"""
aggregate fields of "time_log"
"""
type time_log_aggregate_fields {
  count(columns: [time_log_select_column!], distinct: Boolean): Int
  max: time_log_max_fields
  min: time_log_min_fields
}

"""
order by aggregate values of table "time_log"
"""
input time_log_aggregate_order_by {
  count: order_by
  max: time_log_max_order_by
  min: time_log_min_order_by
}

"""
input type for inserting array relation for remote table "time_log"
"""
input time_log_arr_rel_insert_input {
  data: [time_log_insert_input!]!
  on_conflict: time_log_on_conflict
}

"""
Boolean expression to filter rows from the table "time_log". All fields are combined with a logical 'AND'.
"""
input time_log_bool_exp {
  _and: [time_log_bool_exp]
  _not: time_log_bool_exp
  _or: [time_log_bool_exp]
  createdAt: timestamp_comparison_exp
  deletedAt: timestamp_comparison_exp
  description: String_comparison_exp
  employee: employee_bool_exp
  employeeId: uuid_comparison_exp
  id: uuid_comparison_exp
  isBillable: Boolean_comparison_exp
  logType: String_comparison_exp
  organizationContactId: uuid_comparison_exp
  organizationId: uuid_comparison_exp
  projectId: uuid_comparison_exp
  reason: String_comparison_exp
  source: String_comparison_exp
  startedAt: timestamp_comparison_exp
  stoppedAt: timestamp_comparison_exp
  task: task_bool_exp
  taskId: uuid_comparison_exp
  tenantId: uuid_comparison_exp
  time_slot_time_logs: time_slot_time_logs_bool_exp
  timesheet: timesheet_bool_exp
  timesheetId: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "time_log"
"""
enum time_log_constraint {
  """
  unique or primary key constraint
  """
  PK_b74817f73944f78f239601069f2
}

"""
input type for inserting data into table "time_log"
"""
input time_log_insert_input {
  createdAt: timestamp
  deletedAt: timestamp
  description: String
  employee: employee_obj_rel_insert_input
  employeeId: uuid
  id: uuid
  isBillable: Boolean
  logType: String
  organizationContactId: uuid
  organizationId: uuid
  projectId: uuid
  reason: String
  source: String
  startedAt: timestamp
  stoppedAt: timestamp
  task: task_obj_rel_insert_input
  taskId: uuid
  tenantId: uuid
  time_slot_time_logs: time_slot_time_logs_arr_rel_insert_input
  timesheet: timesheet_obj_rel_insert_input
  timesheetId: uuid
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type time_log_max_fields {
  createdAt: timestamp
  deletedAt: timestamp
  description: String
  employeeId: uuid
  id: uuid
  logType: String
  organizationContactId: uuid
  organizationId: uuid
  projectId: uuid
  reason: String
  source: String
  startedAt: timestamp
  stoppedAt: timestamp
  taskId: uuid
  tenantId: uuid
  timesheetId: uuid
  updatedAt: timestamp
}

"""
order by max() on columns of table "time_log"
"""
input time_log_max_order_by {
  createdAt: order_by
  deletedAt: order_by
  description: order_by
  employeeId: order_by
  id: order_by
  logType: order_by
  organizationContactId: order_by
  organizationId: order_by
  projectId: order_by
  reason: order_by
  source: order_by
  startedAt: order_by
  stoppedAt: order_by
  taskId: order_by
  tenantId: order_by
  timesheetId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type time_log_min_fields {
  createdAt: timestamp
  deletedAt: timestamp
  description: String
  employeeId: uuid
  id: uuid
  logType: String
  organizationContactId: uuid
  organizationId: uuid
  projectId: uuid
  reason: String
  source: String
  startedAt: timestamp
  stoppedAt: timestamp
  taskId: uuid
  tenantId: uuid
  timesheetId: uuid
  updatedAt: timestamp
}

"""
order by min() on columns of table "time_log"
"""
input time_log_min_order_by {
  createdAt: order_by
  deletedAt: order_by
  description: order_by
  employeeId: order_by
  id: order_by
  logType: order_by
  organizationContactId: order_by
  organizationId: order_by
  projectId: order_by
  reason: order_by
  source: order_by
  startedAt: order_by
  stoppedAt: order_by
  taskId: order_by
  tenantId: order_by
  timesheetId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "time_log"
"""
type time_log_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [time_log!]!
}

"""
input type for inserting object relation for remote table "time_log"
"""
input time_log_obj_rel_insert_input {
  data: time_log_insert_input!
  on_conflict: time_log_on_conflict
}

"""
on conflict condition type for table "time_log"
"""
input time_log_on_conflict {
  constraint: time_log_constraint!
  update_columns: [time_log_update_column!]!
  where: time_log_bool_exp
}

"""
ordering options when selecting data from "time_log"
"""
input time_log_order_by {
  createdAt: order_by
  deletedAt: order_by
  description: order_by
  employee: employee_order_by
  employeeId: order_by
  id: order_by
  isBillable: order_by
  logType: order_by
  organizationContactId: order_by
  organizationId: order_by
  projectId: order_by
  reason: order_by
  source: order_by
  startedAt: order_by
  stoppedAt: order_by
  task: task_order_by
  taskId: order_by
  tenantId: order_by
  time_slot_time_logs_aggregate: time_slot_time_logs_aggregate_order_by
  timesheet: timesheet_order_by
  timesheetId: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "time_log"
"""
input time_log_pk_columns_input {
  id: uuid!
}

"""
select columns of table "time_log"
"""
enum time_log_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  deletedAt

  """
  column name
  """
  description

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  isBillable

  """
  column name
  """
  logType

  """
  column name
  """
  organizationContactId

  """
  column name
  """
  organizationId

  """
  column name
  """
  projectId

  """
  column name
  """
  reason

  """
  column name
  """
  source

  """
  column name
  """
  startedAt

  """
  column name
  """
  stoppedAt

  """
  column name
  """
  taskId

  """
  column name
  """
  tenantId

  """
  column name
  """
  timesheetId

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "time_log"
"""
input time_log_set_input {
  createdAt: timestamp
  deletedAt: timestamp
  description: String
  employeeId: uuid
  id: uuid
  isBillable: Boolean
  logType: String
  organizationContactId: uuid
  organizationId: uuid
  projectId: uuid
  reason: String
  source: String
  startedAt: timestamp
  stoppedAt: timestamp
  taskId: uuid
  tenantId: uuid
  timesheetId: uuid
  updatedAt: timestamp
}

"""
update columns of table "time_log"
"""
enum time_log_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  deletedAt

  """
  column name
  """
  description

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  isBillable

  """
  column name
  """
  logType

  """
  column name
  """
  organizationContactId

  """
  column name
  """
  organizationId

  """
  column name
  """
  projectId

  """
  column name
  """
  reason

  """
  column name
  """
  source

  """
  column name
  """
  startedAt

  """
  column name
  """
  stoppedAt

  """
  column name
  """
  taskId

  """
  column name
  """
  tenantId

  """
  column name
  """
  timesheetId

  """
  column name
  """
  updatedAt
}

"""
columns and relationships of "time_slot"
"""
type time_slot {
  """
  An array relationship
  """
  activities(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): [activity!]!

  """
  An aggregated array relationship
  """
  activities_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [activity_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activity_order_by!]

    """
    filter the rows returned
    """
    where: activity_bool_exp
  ): activity_aggregate!
  createdAt: timestamp!
  duration: Int!

  """
  An object relationship
  """
  employee: employee!
  employeeId: uuid!
  id: uuid!
  keyboard: Int!
  mouse: Int!
  organizationId: uuid
  overall: Int!

  """
  An array relationship
  """
  screenshots(
    """
    distinct select on columns
    """
    distinct_on: [screenshot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [screenshot_order_by!]

    """
    filter the rows returned
    """
    where: screenshot_bool_exp
  ): [screenshot!]!

  """
  An aggregated array relationship
  """
  screenshots_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [screenshot_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [screenshot_order_by!]

    """
    filter the rows returned
    """
    where: screenshot_bool_exp
  ): screenshot_aggregate!
  startedAt: timestamp!
  tenantId: uuid

  """
  An array relationship
  """
  time_slot_minutes(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_minute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_minute_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_minute_bool_exp
  ): [time_slot_minute!]!

  """
  An aggregated array relationship
  """
  time_slot_minutes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_minute_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_minute_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_minute_bool_exp
  ): time_slot_minute_aggregate!

  """
  An array relationship
  """
  time_slot_time_logs(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_time_logs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_time_logs_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_time_logs_bool_exp
  ): [time_slot_time_logs!]!

  """
  An aggregated array relationship
  """
  time_slot_time_logs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_slot_time_logs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_slot_time_logs_order_by!]

    """
    filter the rows returned
    """
    where: time_slot_time_logs_bool_exp
  ): time_slot_time_logs_aggregate!
  updatedAt: timestamp!
}

"""
aggregated selection of "time_slot"
"""
type time_slot_aggregate {
  aggregate: time_slot_aggregate_fields
  nodes: [time_slot!]!
}

"""
aggregate fields of "time_slot"
"""
type time_slot_aggregate_fields {
  avg: time_slot_avg_fields
  count(columns: [time_slot_select_column!], distinct: Boolean): Int
  max: time_slot_max_fields
  min: time_slot_min_fields
  stddev: time_slot_stddev_fields
  stddev_pop: time_slot_stddev_pop_fields
  stddev_samp: time_slot_stddev_samp_fields
  sum: time_slot_sum_fields
  var_pop: time_slot_var_pop_fields
  var_samp: time_slot_var_samp_fields
  variance: time_slot_variance_fields
}

"""
order by aggregate values of table "time_slot"
"""
input time_slot_aggregate_order_by {
  avg: time_slot_avg_order_by
  count: order_by
  max: time_slot_max_order_by
  min: time_slot_min_order_by
  stddev: time_slot_stddev_order_by
  stddev_pop: time_slot_stddev_pop_order_by
  stddev_samp: time_slot_stddev_samp_order_by
  sum: time_slot_sum_order_by
  var_pop: time_slot_var_pop_order_by
  var_samp: time_slot_var_samp_order_by
  variance: time_slot_variance_order_by
}

"""
input type for inserting array relation for remote table "time_slot"
"""
input time_slot_arr_rel_insert_input {
  data: [time_slot_insert_input!]!
  on_conflict: time_slot_on_conflict
}

"""
aggregate avg on columns
"""
type time_slot_avg_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by avg() on columns of table "time_slot"
"""
input time_slot_avg_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
Boolean expression to filter rows from the table "time_slot". All fields are combined with a logical 'AND'.
"""
input time_slot_bool_exp {
  _and: [time_slot_bool_exp]
  _not: time_slot_bool_exp
  _or: [time_slot_bool_exp]
  activities: activity_bool_exp
  createdAt: timestamp_comparison_exp
  duration: Int_comparison_exp
  employee: employee_bool_exp
  employeeId: uuid_comparison_exp
  id: uuid_comparison_exp
  keyboard: Int_comparison_exp
  mouse: Int_comparison_exp
  organizationId: uuid_comparison_exp
  overall: Int_comparison_exp
  screenshots: screenshot_bool_exp
  startedAt: timestamp_comparison_exp
  tenantId: uuid_comparison_exp
  time_slot_minutes: time_slot_minute_bool_exp
  time_slot_time_logs: time_slot_time_logs_bool_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "time_slot"
"""
enum time_slot_constraint {
  """
  unique or primary key constraint
  """
  PK_03f782f8c4af029253f6ad5bacf
}

"""
input type for incrementing integer column in table "time_slot"
"""
input time_slot_inc_input {
  duration: Int
  keyboard: Int
  mouse: Int
  overall: Int
}

"""
input type for inserting data into table "time_slot"
"""
input time_slot_insert_input {
  activities: activity_arr_rel_insert_input
  createdAt: timestamp
  duration: Int
  employee: employee_obj_rel_insert_input
  employeeId: uuid
  id: uuid
  keyboard: Int
  mouse: Int
  organizationId: uuid
  overall: Int
  screenshots: screenshot_arr_rel_insert_input
  startedAt: timestamp
  tenantId: uuid
  time_slot_minutes: time_slot_minute_arr_rel_insert_input
  time_slot_time_logs: time_slot_time_logs_arr_rel_insert_input
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type time_slot_max_fields {
  createdAt: timestamp
  duration: Int
  employeeId: uuid
  id: uuid
  keyboard: Int
  mouse: Int
  organizationId: uuid
  overall: Int
  startedAt: timestamp
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by max() on columns of table "time_slot"
"""
input time_slot_max_order_by {
  createdAt: order_by
  duration: order_by
  employeeId: order_by
  id: order_by
  keyboard: order_by
  mouse: order_by
  organizationId: order_by
  overall: order_by
  startedAt: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type time_slot_min_fields {
  createdAt: timestamp
  duration: Int
  employeeId: uuid
  id: uuid
  keyboard: Int
  mouse: Int
  organizationId: uuid
  overall: Int
  startedAt: timestamp
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by min() on columns of table "time_slot"
"""
input time_slot_min_order_by {
  createdAt: order_by
  duration: order_by
  employeeId: order_by
  id: order_by
  keyboard: order_by
  mouse: order_by
  organizationId: order_by
  overall: order_by
  startedAt: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
columns and relationships of "time_slot_minute"
"""
type time_slot_minute {
  createdAt: timestamp!
  datetime: timestamp!
  id: uuid!
  keyboard: Int!
  mouse: Int!
  organizationId: uuid
  tenantId: uuid
  timeSlotId: uuid!

  """
  An object relationship
  """
  time_slot: time_slot!
  updatedAt: timestamp!
}

"""
aggregated selection of "time_slot_minute"
"""
type time_slot_minute_aggregate {
  aggregate: time_slot_minute_aggregate_fields
  nodes: [time_slot_minute!]!
}

"""
aggregate fields of "time_slot_minute"
"""
type time_slot_minute_aggregate_fields {
  avg: time_slot_minute_avg_fields
  count(columns: [time_slot_minute_select_column!], distinct: Boolean): Int
  max: time_slot_minute_max_fields
  min: time_slot_minute_min_fields
  stddev: time_slot_minute_stddev_fields
  stddev_pop: time_slot_minute_stddev_pop_fields
  stddev_samp: time_slot_minute_stddev_samp_fields
  sum: time_slot_minute_sum_fields
  var_pop: time_slot_minute_var_pop_fields
  var_samp: time_slot_minute_var_samp_fields
  variance: time_slot_minute_variance_fields
}

"""
order by aggregate values of table "time_slot_minute"
"""
input time_slot_minute_aggregate_order_by {
  avg: time_slot_minute_avg_order_by
  count: order_by
  max: time_slot_minute_max_order_by
  min: time_slot_minute_min_order_by
  stddev: time_slot_minute_stddev_order_by
  stddev_pop: time_slot_minute_stddev_pop_order_by
  stddev_samp: time_slot_minute_stddev_samp_order_by
  sum: time_slot_minute_sum_order_by
  var_pop: time_slot_minute_var_pop_order_by
  var_samp: time_slot_minute_var_samp_order_by
  variance: time_slot_minute_variance_order_by
}

"""
input type for inserting array relation for remote table "time_slot_minute"
"""
input time_slot_minute_arr_rel_insert_input {
  data: [time_slot_minute_insert_input!]!
  on_conflict: time_slot_minute_on_conflict
}

"""
aggregate avg on columns
"""
type time_slot_minute_avg_fields {
  keyboard: Float
  mouse: Float
}

"""
order by avg() on columns of table "time_slot_minute"
"""
input time_slot_minute_avg_order_by {
  keyboard: order_by
  mouse: order_by
}

"""
Boolean expression to filter rows from the table "time_slot_minute". All fields are combined with a logical 'AND'.
"""
input time_slot_minute_bool_exp {
  _and: [time_slot_minute_bool_exp]
  _not: time_slot_minute_bool_exp
  _or: [time_slot_minute_bool_exp]
  createdAt: timestamp_comparison_exp
  datetime: timestamp_comparison_exp
  id: uuid_comparison_exp
  keyboard: Int_comparison_exp
  mouse: Int_comparison_exp
  organizationId: uuid_comparison_exp
  tenantId: uuid_comparison_exp
  timeSlotId: uuid_comparison_exp
  time_slot: time_slot_bool_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "time_slot_minute"
"""
enum time_slot_minute_constraint {
  """
  unique or primary key constraint
  """
  PK_620fe1f2b27a920a28c5b8398c2

  """
  unique or primary key constraint
  """
  UQ_0ac1d2777eefcee82db52ca3660
}

"""
input type for incrementing integer column in table "time_slot_minute"
"""
input time_slot_minute_inc_input {
  keyboard: Int
  mouse: Int
}

"""
input type for inserting data into table "time_slot_minute"
"""
input time_slot_minute_insert_input {
  createdAt: timestamp
  datetime: timestamp
  id: uuid
  keyboard: Int
  mouse: Int
  organizationId: uuid
  tenantId: uuid
  timeSlotId: uuid
  time_slot: time_slot_obj_rel_insert_input
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type time_slot_minute_max_fields {
  createdAt: timestamp
  datetime: timestamp
  id: uuid
  keyboard: Int
  mouse: Int
  organizationId: uuid
  tenantId: uuid
  timeSlotId: uuid
  updatedAt: timestamp
}

"""
order by max() on columns of table "time_slot_minute"
"""
input time_slot_minute_max_order_by {
  createdAt: order_by
  datetime: order_by
  id: order_by
  keyboard: order_by
  mouse: order_by
  organizationId: order_by
  tenantId: order_by
  timeSlotId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type time_slot_minute_min_fields {
  createdAt: timestamp
  datetime: timestamp
  id: uuid
  keyboard: Int
  mouse: Int
  organizationId: uuid
  tenantId: uuid
  timeSlotId: uuid
  updatedAt: timestamp
}

"""
order by min() on columns of table "time_slot_minute"
"""
input time_slot_minute_min_order_by {
  createdAt: order_by
  datetime: order_by
  id: order_by
  keyboard: order_by
  mouse: order_by
  organizationId: order_by
  tenantId: order_by
  timeSlotId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "time_slot_minute"
"""
type time_slot_minute_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [time_slot_minute!]!
}

"""
input type for inserting object relation for remote table "time_slot_minute"
"""
input time_slot_minute_obj_rel_insert_input {
  data: time_slot_minute_insert_input!
  on_conflict: time_slot_minute_on_conflict
}

"""
on conflict condition type for table "time_slot_minute"
"""
input time_slot_minute_on_conflict {
  constraint: time_slot_minute_constraint!
  update_columns: [time_slot_minute_update_column!]!
  where: time_slot_minute_bool_exp
}

"""
ordering options when selecting data from "time_slot_minute"
"""
input time_slot_minute_order_by {
  createdAt: order_by
  datetime: order_by
  id: order_by
  keyboard: order_by
  mouse: order_by
  organizationId: order_by
  tenantId: order_by
  timeSlotId: order_by
  time_slot: time_slot_order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "time_slot_minute"
"""
input time_slot_minute_pk_columns_input {
  id: uuid!
}

"""
select columns of table "time_slot_minute"
"""
enum time_slot_minute_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  datetime

  """
  column name
  """
  id

  """
  column name
  """
  keyboard

  """
  column name
  """
  mouse

  """
  column name
  """
  organizationId

  """
  column name
  """
  tenantId

  """
  column name
  """
  timeSlotId

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "time_slot_minute"
"""
input time_slot_minute_set_input {
  createdAt: timestamp
  datetime: timestamp
  id: uuid
  keyboard: Int
  mouse: Int
  organizationId: uuid
  tenantId: uuid
  timeSlotId: uuid
  updatedAt: timestamp
}

"""
aggregate stddev on columns
"""
type time_slot_minute_stddev_fields {
  keyboard: Float
  mouse: Float
}

"""
order by stddev() on columns of table "time_slot_minute"
"""
input time_slot_minute_stddev_order_by {
  keyboard: order_by
  mouse: order_by
}

"""
aggregate stddev_pop on columns
"""
type time_slot_minute_stddev_pop_fields {
  keyboard: Float
  mouse: Float
}

"""
order by stddev_pop() on columns of table "time_slot_minute"
"""
input time_slot_minute_stddev_pop_order_by {
  keyboard: order_by
  mouse: order_by
}

"""
aggregate stddev_samp on columns
"""
type time_slot_minute_stddev_samp_fields {
  keyboard: Float
  mouse: Float
}

"""
order by stddev_samp() on columns of table "time_slot_minute"
"""
input time_slot_minute_stddev_samp_order_by {
  keyboard: order_by
  mouse: order_by
}

"""
aggregate sum on columns
"""
type time_slot_minute_sum_fields {
  keyboard: Int
  mouse: Int
}

"""
order by sum() on columns of table "time_slot_minute"
"""
input time_slot_minute_sum_order_by {
  keyboard: order_by
  mouse: order_by
}

"""
update columns of table "time_slot_minute"
"""
enum time_slot_minute_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  datetime

  """
  column name
  """
  id

  """
  column name
  """
  keyboard

  """
  column name
  """
  mouse

  """
  column name
  """
  organizationId

  """
  column name
  """
  tenantId

  """
  column name
  """
  timeSlotId

  """
  column name
  """
  updatedAt
}

"""
aggregate var_pop on columns
"""
type time_slot_minute_var_pop_fields {
  keyboard: Float
  mouse: Float
}

"""
order by var_pop() on columns of table "time_slot_minute"
"""
input time_slot_minute_var_pop_order_by {
  keyboard: order_by
  mouse: order_by
}

"""
aggregate var_samp on columns
"""
type time_slot_minute_var_samp_fields {
  keyboard: Float
  mouse: Float
}

"""
order by var_samp() on columns of table "time_slot_minute"
"""
input time_slot_minute_var_samp_order_by {
  keyboard: order_by
  mouse: order_by
}

"""
aggregate variance on columns
"""
type time_slot_minute_variance_fields {
  keyboard: Float
  mouse: Float
}

"""
order by variance() on columns of table "time_slot_minute"
"""
input time_slot_minute_variance_order_by {
  keyboard: order_by
  mouse: order_by
}

"""
response of any mutation on the table "time_slot"
"""
type time_slot_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [time_slot!]!
}

"""
input type for inserting object relation for remote table "time_slot"
"""
input time_slot_obj_rel_insert_input {
  data: time_slot_insert_input!
  on_conflict: time_slot_on_conflict
}

"""
on conflict condition type for table "time_slot"
"""
input time_slot_on_conflict {
  constraint: time_slot_constraint!
  update_columns: [time_slot_update_column!]!
  where: time_slot_bool_exp
}

"""
ordering options when selecting data from "time_slot"
"""
input time_slot_order_by {
  activities_aggregate: activity_aggregate_order_by
  createdAt: order_by
  duration: order_by
  employee: employee_order_by
  employeeId: order_by
  id: order_by
  keyboard: order_by
  mouse: order_by
  organizationId: order_by
  overall: order_by
  screenshots_aggregate: screenshot_aggregate_order_by
  startedAt: order_by
  tenantId: order_by
  time_slot_minutes_aggregate: time_slot_minute_aggregate_order_by
  time_slot_time_logs_aggregate: time_slot_time_logs_aggregate_order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "time_slot"
"""
input time_slot_pk_columns_input {
  id: uuid!
}

"""
select columns of table "time_slot"
"""
enum time_slot_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  duration

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  keyboard

  """
  column name
  """
  mouse

  """
  column name
  """
  organizationId

  """
  column name
  """
  overall

  """
  column name
  """
  startedAt

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "time_slot"
"""
input time_slot_set_input {
  createdAt: timestamp
  duration: Int
  employeeId: uuid
  id: uuid
  keyboard: Int
  mouse: Int
  organizationId: uuid
  overall: Int
  startedAt: timestamp
  tenantId: uuid
  updatedAt: timestamp
}

"""
aggregate stddev on columns
"""
type time_slot_stddev_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by stddev() on columns of table "time_slot"
"""
input time_slot_stddev_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate stddev_pop on columns
"""
type time_slot_stddev_pop_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by stddev_pop() on columns of table "time_slot"
"""
input time_slot_stddev_pop_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate stddev_samp on columns
"""
type time_slot_stddev_samp_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by stddev_samp() on columns of table "time_slot"
"""
input time_slot_stddev_samp_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate sum on columns
"""
type time_slot_sum_fields {
  duration: Int
  keyboard: Int
  mouse: Int
  overall: Int
}

"""
order by sum() on columns of table "time_slot"
"""
input time_slot_sum_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
columns and relationships of "time_slot_time_logs"
"""
type time_slot_time_logs {
  timeLogId: uuid!
  timeSlotId: uuid!

  """
  An object relationship
  """
  time_log: time_log!

  """
  An object relationship
  """
  time_slot: time_slot!
}

"""
aggregated selection of "time_slot_time_logs"
"""
type time_slot_time_logs_aggregate {
  aggregate: time_slot_time_logs_aggregate_fields
  nodes: [time_slot_time_logs!]!
}

"""
aggregate fields of "time_slot_time_logs"
"""
type time_slot_time_logs_aggregate_fields {
  count(columns: [time_slot_time_logs_select_column!], distinct: Boolean): Int
  max: time_slot_time_logs_max_fields
  min: time_slot_time_logs_min_fields
}

"""
order by aggregate values of table "time_slot_time_logs"
"""
input time_slot_time_logs_aggregate_order_by {
  count: order_by
  max: time_slot_time_logs_max_order_by
  min: time_slot_time_logs_min_order_by
}

"""
input type for inserting array relation for remote table "time_slot_time_logs"
"""
input time_slot_time_logs_arr_rel_insert_input {
  data: [time_slot_time_logs_insert_input!]!
  on_conflict: time_slot_time_logs_on_conflict
}

"""
Boolean expression to filter rows from the table "time_slot_time_logs". All fields are combined with a logical 'AND'.
"""
input time_slot_time_logs_bool_exp {
  _and: [time_slot_time_logs_bool_exp]
  _not: time_slot_time_logs_bool_exp
  _or: [time_slot_time_logs_bool_exp]
  timeLogId: uuid_comparison_exp
  timeSlotId: uuid_comparison_exp
  time_log: time_log_bool_exp
  time_slot: time_slot_bool_exp
}

"""
unique or primary key constraints on table "time_slot_time_logs"
"""
enum time_slot_time_logs_constraint {
  """
  unique or primary key constraint
  """
  PK_84931d1a9078253918390719bd3
}

"""
input type for inserting data into table "time_slot_time_logs"
"""
input time_slot_time_logs_insert_input {
  timeLogId: uuid
  timeSlotId: uuid
  time_log: time_log_obj_rel_insert_input
  time_slot: time_slot_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type time_slot_time_logs_max_fields {
  timeLogId: uuid
  timeSlotId: uuid
}

"""
order by max() on columns of table "time_slot_time_logs"
"""
input time_slot_time_logs_max_order_by {
  timeLogId: order_by
  timeSlotId: order_by
}

"""
aggregate min on columns
"""
type time_slot_time_logs_min_fields {
  timeLogId: uuid
  timeSlotId: uuid
}

"""
order by min() on columns of table "time_slot_time_logs"
"""
input time_slot_time_logs_min_order_by {
  timeLogId: order_by
  timeSlotId: order_by
}

"""
response of any mutation on the table "time_slot_time_logs"
"""
type time_slot_time_logs_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [time_slot_time_logs!]!
}

"""
input type for inserting object relation for remote table "time_slot_time_logs"
"""
input time_slot_time_logs_obj_rel_insert_input {
  data: time_slot_time_logs_insert_input!
  on_conflict: time_slot_time_logs_on_conflict
}

"""
on conflict condition type for table "time_slot_time_logs"
"""
input time_slot_time_logs_on_conflict {
  constraint: time_slot_time_logs_constraint!
  update_columns: [time_slot_time_logs_update_column!]!
  where: time_slot_time_logs_bool_exp
}

"""
ordering options when selecting data from "time_slot_time_logs"
"""
input time_slot_time_logs_order_by {
  timeLogId: order_by
  timeSlotId: order_by
  time_log: time_log_order_by
  time_slot: time_slot_order_by
}

"""
primary key columns input for table: "time_slot_time_logs"
"""
input time_slot_time_logs_pk_columns_input {
  timeLogId: uuid!
  timeSlotId: uuid!
}

"""
select columns of table "time_slot_time_logs"
"""
enum time_slot_time_logs_select_column {
  """
  column name
  """
  timeLogId

  """
  column name
  """
  timeSlotId
}

"""
input type for updating data in table "time_slot_time_logs"
"""
input time_slot_time_logs_set_input {
  timeLogId: uuid
  timeSlotId: uuid
}

"""
update columns of table "time_slot_time_logs"
"""
enum time_slot_time_logs_update_column {
  """
  column name
  """
  timeLogId

  """
  column name
  """
  timeSlotId
}

"""
update columns of table "time_slot"
"""
enum time_slot_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  duration

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  keyboard

  """
  column name
  """
  mouse

  """
  column name
  """
  organizationId

  """
  column name
  """
  overall

  """
  column name
  """
  startedAt

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
aggregate var_pop on columns
"""
type time_slot_var_pop_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by var_pop() on columns of table "time_slot"
"""
input time_slot_var_pop_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate var_samp on columns
"""
type time_slot_var_samp_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by var_samp() on columns of table "time_slot"
"""
input time_slot_var_samp_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate variance on columns
"""
type time_slot_variance_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by variance() on columns of table "time_slot"
"""
input time_slot_variance_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
columns and relationships of "timesheet"
"""
type timesheet {
  approvedAt: timestamp
  approvedById: uuid
  createdAt: timestamp!
  deletedAt: timestamp
  duration: Int!

  """
  An object relationship
  """
  employee: employee

  """
  An object relationship
  """
  employeeByEmployeeid: employee!
  employeeId: uuid!
  id: uuid!
  isBilled: Boolean!
  keyboard: Int!
  lockedAt: timestamp
  mouse: Int!
  organizationId: uuid
  overall: Int!
  startedAt: timestamp
  status: String!
  stoppedAt: timestamp
  submittedAt: timestamp
  tenantId: uuid

  """
  An array relationship
  """
  time_logs(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): [time_log!]!

  """
  An aggregated array relationship
  """
  time_logs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [time_log_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [time_log_order_by!]

    """
    filter the rows returned
    """
    where: time_log_bool_exp
  ): time_log_aggregate!
  updatedAt: timestamp!
}

"""
aggregated selection of "timesheet"
"""
type timesheet_aggregate {
  aggregate: timesheet_aggregate_fields
  nodes: [timesheet!]!
}

"""
aggregate fields of "timesheet"
"""
type timesheet_aggregate_fields {
  avg: timesheet_avg_fields
  count(columns: [timesheet_select_column!], distinct: Boolean): Int
  max: timesheet_max_fields
  min: timesheet_min_fields
  stddev: timesheet_stddev_fields
  stddev_pop: timesheet_stddev_pop_fields
  stddev_samp: timesheet_stddev_samp_fields
  sum: timesheet_sum_fields
  var_pop: timesheet_var_pop_fields
  var_samp: timesheet_var_samp_fields
  variance: timesheet_variance_fields
}

"""
order by aggregate values of table "timesheet"
"""
input timesheet_aggregate_order_by {
  avg: timesheet_avg_order_by
  count: order_by
  max: timesheet_max_order_by
  min: timesheet_min_order_by
  stddev: timesheet_stddev_order_by
  stddev_pop: timesheet_stddev_pop_order_by
  stddev_samp: timesheet_stddev_samp_order_by
  sum: timesheet_sum_order_by
  var_pop: timesheet_var_pop_order_by
  var_samp: timesheet_var_samp_order_by
  variance: timesheet_variance_order_by
}

"""
input type for inserting array relation for remote table "timesheet"
"""
input timesheet_arr_rel_insert_input {
  data: [timesheet_insert_input!]!
  on_conflict: timesheet_on_conflict
}

"""
aggregate avg on columns
"""
type timesheet_avg_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by avg() on columns of table "timesheet"
"""
input timesheet_avg_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
Boolean expression to filter rows from the table "timesheet". All fields are combined with a logical 'AND'.
"""
input timesheet_bool_exp {
  _and: [timesheet_bool_exp]
  _not: timesheet_bool_exp
  _or: [timesheet_bool_exp]
  approvedAt: timestamp_comparison_exp
  approvedById: uuid_comparison_exp
  createdAt: timestamp_comparison_exp
  deletedAt: timestamp_comparison_exp
  duration: Int_comparison_exp
  employee: employee_bool_exp
  employeeByEmployeeid: employee_bool_exp
  employeeId: uuid_comparison_exp
  id: uuid_comparison_exp
  isBilled: Boolean_comparison_exp
  keyboard: Int_comparison_exp
  lockedAt: timestamp_comparison_exp
  mouse: Int_comparison_exp
  organizationId: uuid_comparison_exp
  overall: Int_comparison_exp
  startedAt: timestamp_comparison_exp
  status: String_comparison_exp
  stoppedAt: timestamp_comparison_exp
  submittedAt: timestamp_comparison_exp
  tenantId: uuid_comparison_exp
  time_logs: time_log_bool_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "timesheet"
"""
enum timesheet_constraint {
  """
  unique or primary key constraint
  """
  PK_53c30fa094ae81f166955fb1036
}

"""
input type for incrementing integer column in table "timesheet"
"""
input timesheet_inc_input {
  duration: Int
  keyboard: Int
  mouse: Int
  overall: Int
}

"""
input type for inserting data into table "timesheet"
"""
input timesheet_insert_input {
  approvedAt: timestamp
  approvedById: uuid
  createdAt: timestamp
  deletedAt: timestamp
  duration: Int
  employee: employee_obj_rel_insert_input
  employeeByEmployeeid: employee_obj_rel_insert_input
  employeeId: uuid
  id: uuid
  isBilled: Boolean
  keyboard: Int
  lockedAt: timestamp
  mouse: Int
  organizationId: uuid
  overall: Int
  startedAt: timestamp
  status: String
  stoppedAt: timestamp
  submittedAt: timestamp
  tenantId: uuid
  time_logs: time_log_arr_rel_insert_input
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type timesheet_max_fields {
  approvedAt: timestamp
  approvedById: uuid
  createdAt: timestamp
  deletedAt: timestamp
  duration: Int
  employeeId: uuid
  id: uuid
  keyboard: Int
  lockedAt: timestamp
  mouse: Int
  organizationId: uuid
  overall: Int
  startedAt: timestamp
  status: String
  stoppedAt: timestamp
  submittedAt: timestamp
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by max() on columns of table "timesheet"
"""
input timesheet_max_order_by {
  approvedAt: order_by
  approvedById: order_by
  createdAt: order_by
  deletedAt: order_by
  duration: order_by
  employeeId: order_by
  id: order_by
  keyboard: order_by
  lockedAt: order_by
  mouse: order_by
  organizationId: order_by
  overall: order_by
  startedAt: order_by
  status: order_by
  stoppedAt: order_by
  submittedAt: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type timesheet_min_fields {
  approvedAt: timestamp
  approvedById: uuid
  createdAt: timestamp
  deletedAt: timestamp
  duration: Int
  employeeId: uuid
  id: uuid
  keyboard: Int
  lockedAt: timestamp
  mouse: Int
  organizationId: uuid
  overall: Int
  startedAt: timestamp
  status: String
  stoppedAt: timestamp
  submittedAt: timestamp
  tenantId: uuid
  updatedAt: timestamp
}

"""
order by min() on columns of table "timesheet"
"""
input timesheet_min_order_by {
  approvedAt: order_by
  approvedById: order_by
  createdAt: order_by
  deletedAt: order_by
  duration: order_by
  employeeId: order_by
  id: order_by
  keyboard: order_by
  lockedAt: order_by
  mouse: order_by
  organizationId: order_by
  overall: order_by
  startedAt: order_by
  status: order_by
  stoppedAt: order_by
  submittedAt: order_by
  tenantId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "timesheet"
"""
type timesheet_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [timesheet!]!
}

"""
input type for inserting object relation for remote table "timesheet"
"""
input timesheet_obj_rel_insert_input {
  data: timesheet_insert_input!
  on_conflict: timesheet_on_conflict
}

"""
on conflict condition type for table "timesheet"
"""
input timesheet_on_conflict {
  constraint: timesheet_constraint!
  update_columns: [timesheet_update_column!]!
  where: timesheet_bool_exp
}

"""
ordering options when selecting data from "timesheet"
"""
input timesheet_order_by {
  approvedAt: order_by
  approvedById: order_by
  createdAt: order_by
  deletedAt: order_by
  duration: order_by
  employee: employee_order_by
  employeeByEmployeeid: employee_order_by
  employeeId: order_by
  id: order_by
  isBilled: order_by
  keyboard: order_by
  lockedAt: order_by
  mouse: order_by
  organizationId: order_by
  overall: order_by
  startedAt: order_by
  status: order_by
  stoppedAt: order_by
  submittedAt: order_by
  tenantId: order_by
  time_logs_aggregate: time_log_aggregate_order_by
  updatedAt: order_by
}

"""
primary key columns input for table: "timesheet"
"""
input timesheet_pk_columns_input {
  id: uuid!
}

"""
select columns of table "timesheet"
"""
enum timesheet_select_column {
  """
  column name
  """
  approvedAt

  """
  column name
  """
  approvedById

  """
  column name
  """
  createdAt

  """
  column name
  """
  deletedAt

  """
  column name
  """
  duration

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  isBilled

  """
  column name
  """
  keyboard

  """
  column name
  """
  lockedAt

  """
  column name
  """
  mouse

  """
  column name
  """
  organizationId

  """
  column name
  """
  overall

  """
  column name
  """
  startedAt

  """
  column name
  """
  status

  """
  column name
  """
  stoppedAt

  """
  column name
  """
  submittedAt

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "timesheet"
"""
input timesheet_set_input {
  approvedAt: timestamp
  approvedById: uuid
  createdAt: timestamp
  deletedAt: timestamp
  duration: Int
  employeeId: uuid
  id: uuid
  isBilled: Boolean
  keyboard: Int
  lockedAt: timestamp
  mouse: Int
  organizationId: uuid
  overall: Int
  startedAt: timestamp
  status: String
  stoppedAt: timestamp
  submittedAt: timestamp
  tenantId: uuid
  updatedAt: timestamp
}

"""
aggregate stddev on columns
"""
type timesheet_stddev_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by stddev() on columns of table "timesheet"
"""
input timesheet_stddev_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate stddev_pop on columns
"""
type timesheet_stddev_pop_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by stddev_pop() on columns of table "timesheet"
"""
input timesheet_stddev_pop_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate stddev_samp on columns
"""
type timesheet_stddev_samp_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by stddev_samp() on columns of table "timesheet"
"""
input timesheet_stddev_samp_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate sum on columns
"""
type timesheet_sum_fields {
  duration: Int
  keyboard: Int
  mouse: Int
  overall: Int
}

"""
order by sum() on columns of table "timesheet"
"""
input timesheet_sum_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
update columns of table "timesheet"
"""
enum timesheet_update_column {
  """
  column name
  """
  approvedAt

  """
  column name
  """
  approvedById

  """
  column name
  """
  createdAt

  """
  column name
  """
  deletedAt

  """
  column name
  """
  duration

  """
  column name
  """
  employeeId

  """
  column name
  """
  id

  """
  column name
  """
  isBilled

  """
  column name
  """
  keyboard

  """
  column name
  """
  lockedAt

  """
  column name
  """
  mouse

  """
  column name
  """
  organizationId

  """
  column name
  """
  overall

  """
  column name
  """
  startedAt

  """
  column name
  """
  status

  """
  column name
  """
  stoppedAt

  """
  column name
  """
  submittedAt

  """
  column name
  """
  tenantId

  """
  column name
  """
  updatedAt
}

"""
aggregate var_pop on columns
"""
type timesheet_var_pop_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by var_pop() on columns of table "timesheet"
"""
input timesheet_var_pop_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate var_samp on columns
"""
type timesheet_var_samp_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by var_samp() on columns of table "timesheet"
"""
input timesheet_var_samp_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

"""
aggregate variance on columns
"""
type timesheet_variance_fields {
  duration: Float
  keyboard: Float
  mouse: Float
  overall: Float
}

"""
order by variance() on columns of table "timesheet"
"""
input timesheet_variance_order_by {
  duration: order_by
  keyboard: order_by
  mouse: order_by
  overall: order_by
}

scalar timestamp

"""
expression to compare columns of type timestamp. All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
columns and relationships of "user"
"""
type user {
  createdAt: timestamp!
  email: String

  """
  An object relationship
  """
  employee: employee
  firstName: String
  hash: String
  id: uuid!
  imageUrl: String
  lastName: String
  preferredComponentLayout: String
  preferredLanguage: String

  """
  An object relationship
  """
  role: role
  roleId: uuid

  """
  An array relationship
  """
  tasks(
    """
    distinct select on columns
    """
    distinct_on: [task_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [task_order_by!]

    """
    filter the rows returned
    """
    where: task_bool_exp
  ): [task!]!

  """
  An aggregated array relationship
  """
  tasks_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [task_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [task_order_by!]

    """
    filter the rows returned
    """
    where: task_bool_exp
  ): task_aggregate!
  tenantId: uuid
  thirdPartyId: String
  updatedAt: timestamp!
  username: String
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int
  max: user_max_fields
  min: user_min_fields
}

"""
order by aggregate values of table "user"
"""
input user_aggregate_order_by {
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
}

"""
input type for inserting array relation for remote table "user"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!
  on_conflict: user_on_conflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp]
  _not: user_bool_exp
  _or: [user_bool_exp]
  createdAt: timestamp_comparison_exp
  email: String_comparison_exp
  employee: employee_bool_exp
  firstName: String_comparison_exp
  hash: String_comparison_exp
  id: uuid_comparison_exp
  imageUrl: String_comparison_exp
  lastName: String_comparison_exp
  preferredComponentLayout: String_comparison_exp
  preferredLanguage: String_comparison_exp
  role: role_bool_exp
  roleId: uuid_comparison_exp
  tasks: task_bool_exp
  tenantId: uuid_comparison_exp
  thirdPartyId: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  username: String_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint
  """
  IDX_78a916df40e02a9deb1c4b75ed

  """
  unique or primary key constraint
  """
  IDX_e12875dfb3b1d92d7d7c5377e2

  """
  unique or primary key constraint
  """
  PK_cace4a159ff9f2512dd42373760
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  createdAt: timestamp
  email: String
  employee: employee_obj_rel_insert_input
  firstName: String
  hash: String
  id: uuid
  imageUrl: String
  lastName: String
  preferredComponentLayout: String
  preferredLanguage: String
  role: role_obj_rel_insert_input
  roleId: uuid
  tasks: task_arr_rel_insert_input
  tenantId: uuid
  thirdPartyId: String
  updatedAt: timestamp
  username: String
}

"""
aggregate max on columns
"""
type user_max_fields {
  createdAt: timestamp
  email: String
  firstName: String
  hash: String
  id: uuid
  imageUrl: String
  lastName: String
  preferredComponentLayout: String
  preferredLanguage: String
  roleId: uuid
  tenantId: uuid
  thirdPartyId: String
  updatedAt: timestamp
  username: String
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  createdAt: order_by
  email: order_by
  firstName: order_by
  hash: order_by
  id: order_by
  imageUrl: order_by
  lastName: order_by
  preferredComponentLayout: order_by
  preferredLanguage: order_by
  roleId: order_by
  tenantId: order_by
  thirdPartyId: order_by
  updatedAt: order_by
  username: order_by
}

"""
aggregate min on columns
"""
type user_min_fields {
  createdAt: timestamp
  email: String
  firstName: String
  hash: String
  id: uuid
  imageUrl: String
  lastName: String
  preferredComponentLayout: String
  preferredLanguage: String
  roleId: uuid
  tenantId: uuid
  thirdPartyId: String
  updatedAt: timestamp
  username: String
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  createdAt: order_by
  email: order_by
  firstName: order_by
  hash: order_by
  id: order_by
  imageUrl: order_by
  lastName: order_by
  preferredComponentLayout: order_by
  preferredLanguage: order_by
  roleId: order_by
  tenantId: order_by
  thirdPartyId: order_by
  updatedAt: order_by
  username: order_by
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!
  on_conflict: user_on_conflict
}

"""
on conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

"""
ordering options when selecting data from "user"
"""
input user_order_by {
  createdAt: order_by
  email: order_by
  employee: employee_order_by
  firstName: order_by
  hash: order_by
  id: order_by
  imageUrl: order_by
  lastName: order_by
  preferredComponentLayout: order_by
  preferredLanguage: order_by
  role: role_order_by
  roleId: order_by
  tasks_aggregate: task_aggregate_order_by
  tenantId: order_by
  thirdPartyId: order_by
  updatedAt: order_by
  username: order_by
}

"""
primary key columns input for table: "user"
"""
input user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  email

  """
  column name
  """
  firstName

  """
  column name
  """
  hash

  """
  column name
  """
  id

  """
  column name
  """
  imageUrl

  """
  column name
  """
  lastName

  """
  column name
  """
  preferredComponentLayout

  """
  column name
  """
  preferredLanguage

  """
  column name
  """
  roleId

  """
  column name
  """
  tenantId

  """
  column name
  """
  thirdPartyId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  username
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  createdAt: timestamp
  email: String
  firstName: String
  hash: String
  id: uuid
  imageUrl: String
  lastName: String
  preferredComponentLayout: String
  preferredLanguage: String
  roleId: uuid
  tenantId: uuid
  thirdPartyId: String
  updatedAt: timestamp
  username: String
}

"""
update columns of table "user"
"""
enum user_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  email

  """
  column name
  """
  firstName

  """
  column name
  """
  hash

  """
  column name
  """
  id

  """
  column name
  """
  imageUrl

  """
  column name
  """
  lastName

  """
  column name
  """
  preferredComponentLayout

  """
  column name
  """
  preferredLanguage

  """
  column name
  """
  roleId

  """
  column name
  """
  tenantId

  """
  column name
  """
  thirdPartyId

  """
  column name
  """
  updatedAt

  """
  column name
  """
  username
}

scalar uuid

"""
expression to compare columns of type uuid. All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
